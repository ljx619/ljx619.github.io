<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Python开荒</title>
      <link href="/2023/09/17/Python%E5%BC%80%E8%8D%92/"/>
      <url>/2023/09/17/Python%E5%BC%80%E8%8D%92/</url>
      
        <content type="html"><![CDATA[<h1 id="Python开荒"><a href="#Python开荒" class="headerlink" title="Python开荒"></a>Python开荒</h1><p>安装python环境</p><p>一笔带过  网上好多安装教程  一直下一步就ok</p><hr><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p>Python对大小写敏感</p><p>Python语句没有分号</p><p>一般定义变量用小写字母，特殊的关键字用大写  小写会显示错误</p><p>print()内置输出函数</p><p>input()内置输入函数</p><p>int()强转类型函数</p><p>三个单引号 可以跨行  否则只能通过\续行符连接</p><p><img src="/../images/Python%E5%BC%80%E8%8D%92/image-20230917194010470.png" alt="image-20230917194010470"></p><hr><h2 id="神奇的索引"><a href="#神奇的索引" class="headerlink" title="神奇的索引"></a>神奇的索引</h2><p>字符串</p><p>-1索引得到的是末尾最后一个单词  -2 是倒数第二个  以此类推</p><p><img src="/../images/Python%E5%BC%80%E8%8D%92/image-20230917195117059.png" alt="image-20230917195117059"></p><p>当然这并不是说它不会越界  正向 反向是分别计算的  所以两种超出后都会报错</p><p><img src="/../images/Python%E5%BC%80%E8%8D%92/image-20230917201000080.png" alt="image-20230917201000080"></p><p><img src="/../images/Python%E5%BC%80%E8%8D%92/image-20230917201008608.png" alt="image-20230917201008608"></p><p>还可以这样用  取第一个索引到第二个索引的数据</p><p><img src="/../images/Python%E5%BC%80%E8%8D%92/image-20230917202023533.png" alt="image-20230917202023533"></p><p><img src="/../images/Python%E5%BC%80%E8%8D%92/image-20230917202028575.png" alt="image-20230917202028575"></p><p>不写代表所有</p><hr><p>换Python_子木教程</p><h2 id="Python简述"><a href="#Python简述" class="headerlink" title="Python简述"></a>Python简述</h2><ul><li>Python对大数据分析、人工智能中至关重要的机器学习、深度学习都提供了大力的支持</li><li>背后又庞大的“代码库”</li><li>人们习惯称为“胶水语言”  -因为可以缝合多种语言的模块</li></ul><hr><h2 id="搭建Python环境"><a href="#搭建Python环境" class="headerlink" title="搭建Python环境"></a>搭建Python环境</h2><p>从官方直接下载对应位数的解释器</p><p>安装完成后 开始菜单会添加有Python文件夹里面有自带的g编译器 终端 开发文档 已安装模块文档</p><hr><h2 id="第一个Python程序"><a href="#第一个Python程序" class="headerlink" title="第一个Python程序"></a>第一个Python程序</h2><p>当然是Hello World了</p><p>直接</p><p>print(“Hello world”)</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C51单片机</title>
      <link href="/2023/09/12/51%E5%8D%95%E7%89%87%E6%9C%BA/"/>
      <url>/2023/09/12/51%E5%8D%95%E7%89%87%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="51单片机"><a href="#51单片机" class="headerlink" title="51单片机"></a>51单片机</h1><h2 id="电平特性"><a href="#电平特性" class="headerlink" title="电平特性"></a>电平特性</h2><p><img src="/../images/51%E5%8D%95%E7%89%87%E6%9C%BA/image-20230910133058035.png" alt="image-20230910133058035"></p><p>1高电平</p><p>0低电平</p><p>高电平 5V</p><p>低电平 0V</p><p>此外还有电平临界值</p><hr><h2 id="进制与逻辑运算"><a href="#进制与逻辑运算" class="headerlink" title="进制与逻辑运算"></a>进制与逻辑运算</h2><p>二进制</p><p>十六进制 0x</p><p>逻辑运算</p><ul><li>逻辑与</li><li>逻辑或</li><li>逻辑非</li></ul><p><strong>与C语言中一致</strong></p><p>按位取反 符号 ~</p><p>运算</p><p>同或运算</p><ul><li>必须相同，否则没有</li></ul><p> 异或运算</p><ul><li>必须不同，否则没有</li></ul><hr><h2 id="C简介"><a href="#C简介" class="headerlink" title="C简介"></a>C简介</h2><p>发展史–</p><p>很多硬件使用C语言进行开发</p><p>对平台依赖比较低</p><p>效率高   硬件开发友好</p><p>单片开发中  C语言还有汇编语言  C语言有很大的优点</p><p>C语言比较结构化</p><h3 id="C数据类型"><a href="#C数据类型" class="headerlink" title="C数据类型"></a>C数据类型</h3><p><img src="/../images/51%E5%8D%95%E7%89%87%E6%9C%BA/image-20230911133735042.png" alt="image-20230911133735042"></p><p>数组和结构体使用还是蛮多的</p><p>可以让程序结构优化</p><p>C语言指针类型  是C的<u><em>灵魂</em></u></p><p><img src="/../images/51%E5%8D%95%E7%89%87%E6%9C%BA/image-20230911133916656.png" alt="image-20230911133916656"></p><p>常量 变量等等</p><p>单片机也需要运算 ，为了合理运用内存空间 ，所以要使用好数据类型</p><hr><h2 id="C51基础知识"><a href="#C51基础知识" class="headerlink" title="C51基础知识"></a>C51基础知识</h2><h3 id="C51扩充数据类型"><a href="#C51扩充数据类型" class="headerlink" title="C51扩充数据类型"></a>C51扩充数据类型</h3><p><img src="/../images/51%E5%8D%95%E7%89%87%E6%9C%BA/image-20230911193450357.png" alt="image-20230911193450357"></p><p>所有声明  都在头文件中提供了 初学者可以先不了解</p><p> sfr寄存器声明</p><p> 例如：sfr SCON = 0x98</p><p>例如： sbit TI = SCON^1</p><p>类型转换规律  大的转换到小的</p><hr><p>C51运算量</p><ol><li><p>常量</p><p>常量是指在程序执行过程中其值不能改变的量。</p></li><li><p>变量<br>变量是在程序运行过程中其值可以改变的量。<br>[存储种类]  数据类型说明符 [存储器类型]  变量名 1[=初值],变量名 2 [初值]…<br>typedef c51固有的数据类型说明符  别名；</p></li></ol><hr><p>暂时跳过C基础部分  回头复习 其中的C51特性 稍后研究</p><p>直接开始 江科大51单片机教程</p><hr><h1 id="江科大-C51单片机"><a href="#江科大-C51单片机" class="headerlink" title="江科大 C51单片机"></a>江科大 C51单片机</h1><p>手搓代码 让单片机烧起来</p><p> 两款开发工具</p><p>开始肯定需要安装开发工具  51单片机需要两款：</p><ul><li><p>keil 5 编译工具</p></li><li><p>stc-isp 烧录工具</p></li></ul><p>注意安装目录  工具收费 学习过程中可以使用绿色学习版本</p><p>安装破解 正常流程 开始实操</p><hr><h2 id="介绍单片机"><a href="#介绍单片机" class="headerlink" title="介绍单片机"></a>介绍单片机</h2><p>MCU 单片机</p><p>内部集成各种硬件功能等，可以简单理解为超微型电脑</p><p>单品阿吉的任务是信息采集（依靠传感器）处理和硬件设备的控制</p><p>袖珍版计算机，一个芯片就能构成完成的计算机系统。但在性能上，与计算机相差甚远，但是单片机成本低廉、体积小、结构简单，生活和工业控制领域大有所用</p><p><strong>学习使用单片机是了解计算机原理与结构的最佳选择</strong></p><p>单片机使用领域十分广泛，实施工控、通讯设备、导航、家用电器等。这种产品常常冠以“智能型”</p><hr><h2 id="单片机家族"><a href="#单片机家族" class="headerlink" title="单片机家族"></a>单片机家族</h2><p>STC89C52单片机</p><p><img src="/../images/51%E5%8D%95%E7%89%87%E6%9C%BA/image-20230912153054171.png" alt="image-20230912153054171"></p><p>老东西 上世纪80年代的产物 inter开发的 8051单片机  </p><h2 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h2><p><img src="/../images/51%E5%8D%95%E7%89%87%E6%9C%BA/image-20230912155151913.png" alt="image-20230912155151913"></p><h2 id="内部结构图"><a href="#内部结构图" class="headerlink" title="内部结构图"></a>内部结构图</h2><p><img src="/../images/51%E5%8D%95%E7%89%87%E6%9C%BA/image-20230912155953577.png" alt="image-20230912155953577"></p><p>flash闪存 rom io口都是引脚</p><hr><h2 id="单片机最小系统"><a href="#单片机最小系统" class="headerlink" title="单片机最小系统"></a>单片机最小系统</h2><p><img src="/../images/51%E5%8D%95%E7%89%87%E6%9C%BA/image-20230912160259622.png" alt="image-20230912160259622"></p><p>  介绍了开发板</p><hr><h2 id="控制LED"><a href="#控制LED" class="headerlink" title="控制LED"></a>控制LED</h2><p><img src="/../images/51%E5%8D%95%E7%89%87%E6%9C%BA/image-20230912214940299.png" alt="image-20230912214940299"></p><p>小的一端正极  大的负极   长脚正极  短脚负极</p><p>电阻 命名方式 101  =  10 0 类似科学计数法</p><p>如何控制引脚电压</p><p>mcu中包含cpu  还包含寄存器  寄存器通过驱动器来链接引脚  可以给寄存器写值来控制电流 </p><p>程序中不支持直接输入二进制 一般转换为十六进制 或十进制</p><p><img src="/../images/51%E5%8D%95%E7%89%87%E6%9C%BA/image-20230913125958045.png" alt="image-20230913125958045"></p><p>控制p2寄存器 输出电流 控制一个LED灯</p><p><img src="/../images/51%E5%8D%95%E7%89%87%E6%9C%BA/image-20230913131246177.png" alt="image-20230913131246177"></p><p>可以使用stc-isp小工具生成延时代码  灰常好用</p><p>编写延时函数,调整为可定义延时参数的函数</p><hr><h2 id="独立按键"><a href="#独立按键" class="headerlink" title="独立按键"></a>独立按键</h2><p><img src="/../images/51%E5%8D%95%E7%89%87%E6%9C%BA/image-20230913190644554.png" alt="image-20230913190644554"></p><p>数据运算</p><p><img src="/../images/51%E5%8D%95%E7%89%87%E6%9C%BA/image-20230913191921078.png" alt="image-20230913191921078"></p><p>一些结构</p><p><img src="/../images/51%E5%8D%95%E7%89%87%E6%9C%BA/image-20230913192804412.png" alt="image-20230913192804412"></p><hr><p>按键取反操作</p><p>先了解按键的抖动  机械按键开闭的瞬间不会立即连接上电路会有一些干扰</p><p><img src="/../images/51%E5%8D%95%E7%89%87%E6%9C%BA/image-20230913193106976.png" alt="image-20230913193106976"></p><p>消除抖动 两种方法</p><ul><li>硬件防抖 加入一些电路消除</li><li>软件防抖  代码中加入一些延时操作 把抖动跳过 20ms  ok</li></ul><p>按键控制状态</p><p><img src="/../images/51%E5%8D%95%E7%89%87%E6%9C%BA/image-20230913194556127.png" alt="image-20230913194556127"></p><p>按键控制LED如二进制</p><p><img src="/../images/51%E5%8D%95%E7%89%87%E6%9C%BA/image-20230913214451530.png" alt="image-20230913214451530"></p><hr><p>独立按键控制LED移位</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;REGX52.H&gt;</span></span><span class="token comment">//ÑÓÊ±º¯Êý</span><span class="token keyword">void</span> <span class="token function">Delay</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> xms<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> i<span class="token punctuation">,</span>j<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>xms<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> j <span class="token operator">=</span> <span class="token number">239</span><span class="token punctuation">;</span> <span class="token keyword">do</span><span class="token punctuation">{</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">--</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">--</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> LEDNum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>P2 <span class="token operator">=</span> <span class="token operator">~</span><span class="token number">0x01</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span><span class="token punctuation">(</span>P3_1 <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>P3_1 <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>LEDNum <span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>LEDNum <span class="token operator">&gt;=</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">{</span>LEDNum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span>P2 <span class="token operator">=</span> <span class="token operator">~</span><span class="token punctuation">(</span><span class="token number">0x01</span><span class="token operator">&lt;&lt;</span>LEDNum<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">///</span><span class="token keyword">if</span><span class="token punctuation">(</span>P3_0 <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>P3_0 <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>LEDNum <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>LEDNum <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>LEDNum <span class="token operator">--</span><span class="token punctuation">;</span><span class="token punctuation">}</span>P2 <span class="token operator">=</span> <span class="token operator">~</span><span class="token punctuation">(</span><span class="token number">0x01</span><span class="token operator">&lt;&lt;</span>LEDNum<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="LED数码管"><a href="#LED数码管" class="headerlink" title="LED数码管"></a>LED数码管</h2><p><img src="/../images/51%E5%8D%95%E7%89%87%E6%9C%BA/image-20230914092545840.png" alt="image-20230914092545840"></p><hr><p><img src="/../images/51%E5%8D%95%E7%89%87%E6%9C%BA/image-20230914092706346.png" alt="image-20230914092706346"></p><p>上面单的  下面是四位一体 学习用的开发板即是四位一体数码管</p><p><img src="/../images/51%E5%8D%95%E7%89%87%E6%9C%BA/image-20230914094440532.png" alt="image-20230914094440532"></p><hr><p>数组来控制LED数码管</p><p>先引入C51数组概念 即C数组  还有C子函数</p><p><img src="/../images/51%E5%8D%95%E7%89%87%E6%9C%BA/image-20230914144054025.png" alt="image-20230914144054025"></p><p>子函数</p><p><img src="/../images/51%E5%8D%95%E7%89%87%E6%9C%BA/image-20230914144416003.png" alt="image-20230914144416003"></p><p>子函数可以优化代码结构还有代码的复用</p><hr><p><strong>动态数码管显示问题</strong></p><p>需要消影</p><p>因为运算速度太快了 所以造成数据的错乱 在后面加一个延时清零</p><p>数码管驱动方式</p><p><img src="/../images/51%E5%8D%95%E7%89%87%E6%9C%BA/image-20230914154023381.png" alt="image-20230914154023381"></p><hr><hr><h2 id="模块化编程"><a href="#模块化编程" class="headerlink" title="模块化编程"></a>模块化编程</h2><p><img src="/../images/51%E5%8D%95%E7%89%87%E6%9C%BA/image-20230914154325867.png" alt="image-20230914154325867"></p><p><img src="/../images/51%E5%8D%95%E7%89%87%E6%9C%BA/image-20230914154346062.png" alt="image-20230914154346062"></p><p><img src="/../images/51%E5%8D%95%E7%89%87%E6%9C%BA/image-20230914155247996.png" alt="image-20230914155247996"></p><hr><p>LCD调试 封装好的 导进去  直接调用封装好的函数 可以显示调试</p><hr><h2 id="矩阵键盘"><a href="#矩阵键盘" class="headerlink" title="矩阵键盘"></a>矩阵键盘</h2><p>读取矩阵键盘的键码值</p><p><img src="/../images/51%E5%8D%95%E7%89%87%E6%9C%BA/image-20230914203652778.png" alt="image-20230914203652778"></p><p>矩阵形式来减少IO口占用</p><p>扫描的概念</p><p><img src="/../images/51%E5%8D%95%E7%89%87%E6%9C%BA/image-20230914204929819.png" alt="image-20230914204929819"></p><p>扫描速度非常快  所以人眼无法看出闪烁</p><p>节省IO口</p><p> 这里开发板按行扫描  蜂鸣器会响  所以这里采用按列扫描</p><p>手册与开发板原理图 非常重要 需要能看懂</p><p>双向口   开漏输出</p><p>在Keil 5 中 左边布局 有一个Templates 可以简化输入</p><hr><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p><img src="/../images/51%E5%8D%95%E7%89%87%E6%9C%BA/image-20230915174654592.png" alt="image-20230915174654592"></p><p><img src="/../images/51%E5%8D%95%E7%89%87%E6%9C%BA/image-20230915175058905.png" alt="image-20230915175058905"></p><p><img src="/../images/51%E5%8D%95%E7%89%87%E6%9C%BA/image-20230916145647927.png" alt="image-20230916145647927"></p><p><img src="/../images/51%E5%8D%95%E7%89%87%E6%9C%BA/image-20230916150134499.png" alt="image-20230916150134499"></p><ul><li>SYSclk: 系统时钟，即晶振周期，本开发板上的晶振位12MHz</li></ul><hr><h2 id="中断系统"><a href="#中断系统" class="headerlink" title="中断系统"></a>中断系统</h2><p><img src="/../images/51%E5%8D%95%E7%89%87%E6%9C%BA/image-20230916152747609.png" alt="image-20230916152747609"></p><p><img src="/../images/51%E5%8D%95%E7%89%87%E6%9C%BA/image-20230916152859456.png" alt="image-20230916152859456"></p><p><img src="/../images/51%E5%8D%95%E7%89%87%E6%9C%BA/image-20230916160240265.png" alt="image-20230916160240265"></p><p>一堆电路电门需要区分</p><hr><p>TMOD 工作模式寄存器</p><p>TCON 计数器控制寄存器</p><p>定时器可以使用stp-isp工具生成</p>]]></content>
      
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用Linux系统编写C程序</title>
      <link href="/2023/08/25/%E7%94%A8Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E5%86%99C%E7%A8%8B%E5%BA%8F/"/>
      <url>/2023/08/25/%E7%94%A8Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E5%86%99C%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="如何用Linux系统编写C语言程序"><a href="#如何用Linux系统编写C语言程序" class="headerlink" title="如何用Linux系统编写C语言程序"></a>如何用Linux系统编写C语言程序</h1><h2 id="为什么写这一篇博客"><a href="#为什么写这一篇博客" class="headerlink" title="为什么写这一篇博客"></a>为什么写这一篇博客</h2><ol><li>接下来一学期有一门关于使用Linux系统编写C语言程序的课程，Linux编写C程序与windows编写差别比较大，所以写此篇博客来记录自己学习过程</li><li>本篇将在下一学期跟随老师学习过程中持续更新</li></ol><h2 id="打开虚拟机进入Linux"><a href="#打开虚拟机进入Linux" class="headerlink" title="打开虚拟机进入Linux"></a>打开虚拟机进入Linux</h2><p>这第一步自然是启动安装好的Linux系统。</p><h2 id="Linux打开终端界面"><a href="#Linux打开终端界面" class="headerlink" title="Linux打开终端界面"></a>Linux打开终端界面</h2><p>在上一篇博客中记录了如何安装ubuntu虚拟机，此篇直接操作</p><ol><li>按下快捷键打开终端：Ctrl+Alt+T</li><li>从工具栏中点击启动终端</li></ol><h2 id="终端里的常见命令及作用"><a href="#终端里的常见命令及作用" class="headerlink" title="终端里的常见命令及作用"></a>终端里的常见命令及作用</h2><pre class="line-numbers language-none"><code class="language-none">1.cd cd指返回当前目录： 如cd Desktop/program 便是指返回到Desktop（桌面）的program 文件夹； 2.gedit gedit指打开某文件或创建某文件，相当于windows的记事本，当所在目录没有该文件时，就会重新创建该文件，倘若有，则file直接打开该文件； 如gedit Isprimer.c 便指打开或创建Isprimer.c的文件 3.gcc gcc是编译器，其格式为gcc ［options］［filenames］，即gcc编译器根据输入的选 择命令对文件进行相应处理。 gcc 文件 指生成可执行文件 gcc -g 文件 -g的作用是在进行gdb调试时调出代码 gcc -o 文件名 文件 修改文件的名称 -std = c99 有些格式如for(int i = 1; i &lt; 5; i++)在for循环中定义变量，就要参考c99标准 －lm sqrt函数无法编译成功，在编译指令补上-lm （特殊函数就需要加上）4.“./” ./指当前目录，./ 文件指执行当前目录下文件 。/.a.out 表示执行a.out可执行文件 5.gdb gdb指gdb调试 1.输入file 文件，表示gdb调试的对象； 2.输入l，显示出程序的代码； 3.输入b n(数字) 表示设置的断点位置； 4.输入r表示调试开始； 5.输入s或n(字母)表示进入下一步； 6.输入p 变量名可查看该变量的数值； 7.输入q 退出gdb调试。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ps：这么多自然是网上复制粘贴的😁</p><h2 id="配置C语言环境"><a href="#配置C语言环境" class="headerlink" title="配置C语言环境"></a>配置C语言环境</h2><p>在Linux环境下编写C程序需要先配置好C的环境</p><h3 id="安装C编译器"><a href="#安装C编译器" class="headerlink" title="安装C编译器"></a>安装C编译器</h3><p>在Ubuntu中，可以使用一下命令安装GCC：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> gcc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装过程中会询问一些权限输入y即可</p><p>等待安装完毕后 输入gcc -v即可查看是否安装成功</p><p><img src="/../images/%E7%94%A8Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E5%86%99C%E7%A8%8B%E5%BA%8F/image-20230825164833911.png" alt="image-20230825164833911"></p><p>最后一行出现版本信息则是安装成功</p><h2 id="安装调试器"><a href="#安装调试器" class="headerlink" title="安装调试器"></a>安装调试器</h2><p>调试器可以帮助程序员在开发过程中定位和解决程序中的错误。</p><p>常用的调试器有 GDB、LLDB 和 DDD 等。可以使用包管理工具安装调试器。</p><p>例如，在 Ubuntu 中，可以使用以下命令安装 GDB：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> gdb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="使用终端编写C语言"><a href="#使用终端编写C语言" class="headerlink" title="使用终端编写C语言"></a>使用终端编写C语言</h2><p>以编写helloworld程序为例。</p><ol><li><p>用ctrl+alt+t来打开终端</p></li><li><p>要在某个文件夹里创建C文件，首先要有一个文件夹  创建文件夹</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> 文件名 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>进入该文件夹中</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> 创建的文件夹名称<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>建立文本</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gedit helloworld.c  //按下回车后，会跳出一个类似于记事本的编辑器<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>在里面编写代码</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello world!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>保存代码，关闭文本框<br>ctrl+s保存退出即可</p></li><li><p>启动gcc对代码进行编译</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc <span class="token parameter variable">-o</span> helloworld helloworld.c //-o参数指定输出 可选参数<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此步骤会生成一个helloworld运行文件</p></li><li><p>运行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./helloworld  //开始运行 在终端中可以看到输出的helloworld<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p><img src="/../images/%E7%94%A8Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E5%86%99C%E7%A8%8B%E5%BA%8F/image-20230825171736197.png" alt="image-20230825171736197"></p><p><strong>利用Linux编写一个简单C程序 到此结束</strong></p><p>目前没有使用到调试器与vim编辑器 不作介绍</p><p>– ubuntu图形化界面对新手比较友好</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VMware安装Ubuntu</title>
      <link href="/2023/08/24/VMware%E5%AE%89%E8%A3%85Ubuntu/"/>
      <url>/2023/08/24/VMware%E5%AE%89%E8%A3%85Ubuntu/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux操作系统安装"><a href="#Linux操作系统安装" class="headerlink" title="Linux操作系统安装"></a>Linux操作系统安装</h1><p>本次安装使用的是虚拟机的方式安装Linux操作系统</p><h2 id="安装虚拟机"><a href="#安装虚拟机" class="headerlink" title="安装虚拟机"></a>安装虚拟机</h2><p>这里使用的是VMware Workstation Player虚拟机软件 仅仅个人学习使用是免费的</p><p><a href="https://www.vmware.com/cn/products/workstation-player.html">VMware Workstation Player | VMware | CN</a> 直接百度搜索打开官网  或者直接点击前面的链接</p><p>下载最新版本 选择windows操作系统 等待下载后安装即可   </p><h2 id="创建虚拟机"><a href="#创建虚拟机" class="headerlink" title="创建虚拟机"></a>创建虚拟机</h2><p>每一个虚拟机为一个单独的操作系统   可在虚拟机中安装多种操作系统的虚拟机</p><p>需要安装Linux操作系统 就需要一个Linux操作系统的镜像文件  </p><p>Linux系统有多种发行版 主流的有两种</p><ul><li>CentOS   目前已经停止维护更新</li><li>Ubuntu</li></ul><p>这里选用Ubuntu系统 这也是一个非常流行的Linux发行版</p><p>进入官网<a href="https://cn.ubuntu.com/download/desktop">下载Ubuntu桌面系统 | Ubuntu</a>这里选择最新的桌面端LTS长期维护版</p><p>往下翻下载后缀为iso后缀的镜像文件</p><p><img src="/../images/VMware%E5%AE%89%E8%A3%85Ubuntu/image-20230824192926694.png" alt="image-20230824192926694"></p><p>随后在虚拟机创建界面选择镜像</p><p><img src="/../images/VMware%E5%AE%89%E8%A3%85Ubuntu/image-20230824193035841.png" alt="image-20230824193035841"></p><p>然后进行相关配置  Linux计算机名称 账户等   还可以给其分配硬件 内存 cpu核心数等 </p><p><strong>接下来耐心等待即可</strong></p><h2 id="配置Linux"><a href="#配置Linux" class="headerlink" title="配置Linux"></a>配置Linux</h2><p><strong>按windows键调出来搜索</strong></p><ul><li>搜索resolution  选择Displays设置 来修改显示设置</li><li>搜索Language  修改系统语言为简体中文   第一次打开会提示安装支持 安装即可</li></ul><p><strong>到这里Linux系统就算安装完成</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java SE 学习笔记</title>
      <link href="/2023/08/04/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/08/04/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-SE-学习笔记"><a href="#Java-SE-学习笔记" class="headerlink" title="Java SE 学习笔记"></a>Java SE 学习笔记</h1><h2 id="java介绍"><a href="#java介绍" class="headerlink" title="java介绍"></a>java介绍</h2><p>跨平台原理jvm虚拟机</p><p>jre和jdk</p><p>运行一个java程序jre就可以</p><p>开发工具jdk  包含jre和开发工具 jre里面包含jvm以及运行类库 </p><p>jdk下载官方网站<a href="http://www.oracle.com/">www.oracle.com</a></p><p>简单dos命令  需要掌握</p><p>配置变量</p><p>HelloWorld案例</p><p>编译 javac 文件名.java</p><p>运行 java 类名</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>//单行</p><p>/*   */多行</p><p>文档注释（暂时不用）/**   */</p><p>关键字 </p><p>高亮显示</p><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>字符串常量 “你好”</p><p>整数常量 666</p><p>小数常量 12.14</p><p>字符常量 ‘A’</p><p>布尔常量 true false</p><p>空常量 null     这个不能直接输出</p><p>数据类型</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230629095715771-16911320002833.png" alt="image-20230629095715771"></p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>int a = 10;</p><p>变量的使用   取值 a  修改 a = 20</p><p>变量使用的注意事项</p><p>变量要初始化 未赋值不能使用  名字不能重复</p><p>数值默认为int类型 </p><p>浮点数默认为double类型</p><p>定义long类型 防止整数太大问题在值后面加L</p><p>定义float类型    防止不兼容的类型  在值后面加上F 转换为float</p><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p><strong>标识符</strong>：就是给类，方法，变量等起名字的<strong>符号</strong></p><p>定义规则 </p><ul><li>由数字/字母/下划线_和美元符号$组成</li><li>不能以数字开头</li><li>不能是关键字</li><li>区分大小写</li></ul><p>常见的命名约定</p><p><strong>小驼峰命名法：方法、变量</strong></p><ul><li><p>约定1：标识符是一个单词的时候，首字母小写</p></li><li><p>范例1：name</p></li><li><p>约定2：标识符多个字母组成，第一个单词首字母小写，其余单词首字母大写</p></li><li><p>范例2：firstName</p><p><strong>对应的大驼峰： 类</strong></p><p>单词首字母都大写</p></li></ul><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><ul><li><p>自动类型转换  </p><p>把一个范围小的数值或者变量赋值给另外一个表示数据范围大的变量</p><p>示例：double d = 10；</p><p>   <img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230629103338691-16911320002821.png" alt="image-20230629103338691"></p></li><li><p>强制类型转换</p><p>把一个表示数据范围大的数值或者变量赋值给另一个表示范围小的变量</p><ul><li>格式：目标数据类型 变量名 = (目标数据类型)值或者变量;</li><li>示例：int k =(int)88.88;</li></ul><p>强制类型转换不建议 会导致数值的损失</p></li></ul><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p> 运算符和表达式</p><ul><li>运算符：进行操作的符号</li><li>表达式：用运算符把常量或变量连接起来符合java语法的式子就可以称为表达式。不同运算符连接的表达式体现的是不同类型的表达式</li></ul><p> 算术运算符</p><p>​+ 加号- 减号  *乘号  /除号  %取余</p><p>​除法得到的是商，取余得到是余数</p><p>​整数相除只能是整数，要想得到小数，必须由浮点数参与。</p><h2 id="字符的“-”操作"><a href="#字符的“-”操作" class="headerlink" title="字符的“+”操作"></a>字符的“+”操作</h2><p>​字符与int做+操作</p><p>​字符为ASCII值操作  a为97 A为65  0为48</p><p>​int类型和char类型做+操作 结果是int类型的   </p><p>​如果强制转换为char类型则为对应ASCII数值的字符</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230629110227683-16911320002834.png" alt="image-20230629110227683"></p><h2 id="字符串的“-”操作"><a href="#字符串的“-”操作" class="headerlink" title="字符串的“+”操作"></a>字符串的“+”操作</h2><p>​“+”出现在字符串时候，这个是<strong>字符串连接符</strong></p><p>​两个字符串相加为相连</p><p>​字符串和int也可以相连</p><p>​<img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230629112011603-16911320002832.png" alt="image-20230629112011603"></p><p>第一条结果 黑马666</p><p>第二条结果 100年黑马 </p><p>像是从左到右执行</p><p>总结如图</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230629112425847-16911320002836.png" alt="image-20230629112425847"></p><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p><strong>=</strong>  为赋值符</p><p>赋值操作从右到左</p><p>拓展赋值运算符  +=    </p><p>示例  i=10  i += 20  结果为30   i+=20 结果与 i = i+20 相同</p><p>但是 注意+= 蕴含了强制类型转换  </p><p>否则 short s = s +20 会出现int转short问题</p><p>因为s + 20 会变为int类型  解决办法为强制类型转换  这种情况能用 += 则用+= 避免这种类型情况</p><p>其余拓展运算符</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230629113940729-16911320002839.png" alt="image-20230629113940729"></p><p><strong>注意事项：</strong></p><p>拓展的赋值运算符<strong>隐含</strong>了强制类型转换</p><h2 id="自增自减运算符"><a href="#自增自减运算符" class="headerlink" title="自增自减运算符"></a>自增自减运算符</h2><ul><li>符号++   自增</li><li>符号 –    自减</li></ul><p>本身增减       与C语言自增自减符号基本相同   </p><p><strong>注意事项：</strong></p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230629140524972-16911320002835.png" alt="image-20230629140524972"></p><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>关系运算符结果都为布尔型boolean 要么是true要么是false</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230629140609040-16911320002838.png" alt="image-20230629140609040"></p><p>与C语言基本一致   </p><p>注意别把==写成=</p><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p> <img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230629141215757-16911320002837.png" alt="image-20230629141215757"></p><ul><li>逻辑与 &amp;有false则false</li><li>逻辑或 |     有true则true</li><li>逻辑异或 ^ 相同为false，不同为true</li><li>逻辑非 !      true边false，false变true 结果相反</li></ul><p>理论与C相同</p><h3 id="短路逻辑运算符"><a href="#短路逻辑运算符" class="headerlink" title="短路逻辑运算符"></a>短路逻辑运算符</h3><ul><li>短路与 &amp;&amp;</li><li>短路或 ||</li></ul><p>区别  短路与  &amp;&amp; 左边为false 则结果为false不执行右边</p><p>同理  短路或  ||  左边为true  则结果为true不执行右边 </p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230629142731992-169113200028311.png" alt="image-20230629142731992"></p><p><em><strong>最常用的逻辑运算符：&amp;&amp;，||，！</strong></em></p><h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><p>格式：关系表达式？表达式1：表达式2；</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230629142910903-169113200028310.png" alt="image-20230629142910903"></p><h2 id="数据输入"><a href="#数据输入" class="headerlink" title="数据输入"></a>数据输入</h2><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230629144931763-169113200028312.png" alt="image-20230629144931763"></p><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h3><p>顺序结构按照代码先后顺序执行。 从上往下  一句一句执行</p><p>​流程图：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230629151623626-169113200028313.png" alt="image-20230629151623626"></p><h3 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h3><h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><h4 id=""><a href="#" class="headerlink" title=""></a><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230629151136337-169113200028314.png" alt="image-20230629151136337"></h4><p>​流程图：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230629151509618-169113200028315.png" alt="image-20230629151509618"></p><h4 id="if-···-else-语句"><a href="#if-···-else-语句" class="headerlink" title="if ··· else 语句"></a>if ··· else 语句</h4><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230629151725006-169113200028316.png" alt="image-20230629151725006"></p><p>​流程图：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230629152213934-169113200028317.png" alt="image-20230629152213934"></p><h4 id="if-···-else-if-语句"><a href="#if-···-else-if-语句" class="headerlink" title="if ··· else if 语句"></a>if ··· else if 语句</h4><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230629153001411-169113200028418.png" alt="image-20230629153001411"></p><p>​流程图：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230629153301919-169113200028419.png" alt="image-20230629153301919"></p><p>数据测试： 正确数据，边界数据，错误数据</p><h4 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h4><p>​break退出</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230629154403281-169113200028420.png" alt="image-20230629154403281"></p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230629154424256-169113200028422.png" alt="image-20230629154424256"></p><p>​流程图：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230629154826757-169113200028421.png" alt="image-20230629154826757"></p><p>无break则执行满足条件下面的所有语句    被称为：case穿透</p><p>案例：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230629155522970-169113200028423.png" alt="image-20230629155522970"></p><p><strong>注意事项：</strong>在switch语句中，如果case控制的语句体不写break，将出现<strong>穿透</strong></p><p>现象，在不判断下一个case值的情况下，向下运行，直到遇到break或者整体switch语句结束。</p><h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><h4 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h4><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230629160318723-169113200028425.png" alt="image-20230629160318723"></p><p>​流程图:</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230629160542828-169113200028426.png" alt="image-20230629160542828"></p><h5 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h5><pre><code> ![image-20230629162123106](C:\Users\李嘉欣\AppData\Roaming\Typora\typora-user-images\image-20230629162123106.png)</code></pre><p>示例：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230629162737286-169113200028424.png" alt="image-20230629162737286"></p><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230629163818452-169113200028427.png" alt="image-20230629163818452"></p><p>​流程图：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230629164017203-169113200028429.png" alt="image-20230629164017203"></p><h4 id="do-···-while循环"><a href="#do-···-while循环" class="headerlink" title="do ··· while循环"></a>do ··· while循环</h4><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230629164528371-169113200028428.png" alt="image-20230629164528371"></p><p>​流程图：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230629164739759-169113200028431.png" alt="image-20230629164739759"></p><h4 id="三种循环区别"><a href="#三种循环区别" class="headerlink" title="三种循环区别"></a>三种循环区别</h4><p>do  ··· while   至少先执行一次  </p><p>for 和 while区别</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230629165139784-169113200028434.png" alt="image-20230629165139784"></p><p>图  for循环  i   的值是属于for循环的 在for外无法使用  而while定义的 j  没有在while内定义所以可以使用</p><p><strong>死循环</strong></p><p> for( ; ; ) { }   </p><p>while(true) { } </p><p>do{} ··· while(true)；</p><p><strong>总结：</strong></p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230629165637796-169113200028430.png" alt="image-20230629165637796"></p><h4 id="跳转控制语句"><a href="#跳转控制语句" class="headerlink" title="跳转控制语句"></a>跳转控制语句</h4><ul><li>continue用在循环中，基于条件控制，跳过某次循环体内容的执行，继续下一次执行</li><li>break         用在循环中，基于条件控制，终止循环体内容的执行，也就是说结束当前的整个循环</li></ul><h4 id="循环嵌套"><a href="#循环嵌套" class="headerlink" title="循环嵌套"></a>循环嵌套</h4><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230629170448324-169113200028432.png" alt="image-20230629170448324"></p><h2 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h2><p>作用：用于产生一个随机数</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230629174422107-169113200028433.png" alt="image-20230629174422107"></p><h2 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h2><p>安装配置与创建项目 </p><p>IDEA项目结构</p><p>项目-&gt;模块-&gt;包-&gt;java类                              编写代码运行</p><ul><li>快速生成语句</li></ul><p>​快速生成main()方法：psvm，回车</p><p>​快速生成输出语句：sout，回车</p><ul><li>内容辅助键</li></ul><p>​Ctrl+Alt+space(内容提示，代码补全等)</p><ul><li><p>注释</p><p>单行：选中代码，Ctrl+/，再来一次，就是取消</p><p>多行：选中代码，Ctrl+shift+/，再来一次，就是取消</p></li><li><p>格式化</p><p>Ctrl+Alt+L    变为格式化的代码更美观，建议直接按规范来写</p></li></ul><p>模块新建与导入操作</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组array是一种用于存储<strong>多个相同类型</strong>的存储模型</p><p>定义格式：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230630073519881-169113200028435.png" alt="image-20230630073519881"></p><p>数组初始化与动态初始化</p><p>java数组必须先初始化，才能使用</p><ul><li>动态初始化</li></ul><p>​初始化时只指定数组长度，由系统为数组分配初始值</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230630073826825-169113200028436.png" alt="image-20230630073826825"></p><p>数组的元素访问</p><p>arr[0] 访问数组中元素</p><p>输出数组名arr 的话结果为arr的内存地址</p><p>内存分配</p><p>数组在初始化时，会为存储空间添加默认值</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230630080437698-169113200028438.png" alt="image-20230630080437698"></p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230630082414854-169113200028437.png" alt="image-20230630082414854"></p><p>多个数组指向相同</p><p> <img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230630090612071-169113200028439.png" alt="image-20230630090612071"></p><p>指向相同时，任何一个修改堆内存的数据，堆内存值改变，再访问就是改变后的值。</p><ul><li><p>静态初始化</p><pre><code>   初始化指定每一个数组元素的初始值，由系统决定数组长度。</code></pre></li></ul><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230630091354581-169113200028541.png" alt="image-20230630091354581"></p><p>数组操作的两个小问题</p><ul><li><p>索引越界访问了数组中不存在的索引对应的元素，造成索引越界</p><p>越界 定义3个  内存索引为0 1 2     但是访问3则为索引越界</p></li><li><p>空指针异常：访问的数组已经不再指向堆内存的数据，造成空指针异常</p></li></ul><p>数组常见操作</p><ul><li><p>遍历</p><p>为了方便  java提供了获取数组元素个数</p><p>格式为：数组名.length     范例：arr.length</p><p>遍历通用格式：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230630093135615-169113200028542.png" alt="image-20230630093135615"></p></li><li><p>获取最值</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230630093813355-169113200028440.png" alt="image-20230630093813355"></p></li></ul><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>概述</p><p><em><strong>方法(method)<em><strong>是将具有独立功能的</strong></em>代码块</strong></em>组织成一个整体，使其具有特殊功能的<em><strong>代码集</strong></em></p><ul><li>方法先创建才能使用，该过程称为方法定义</li><li>方法创建后并不是直接运行的，需要手动使用，该过程称为方法调用</li></ul><p>方法定义和调用</p><p>​格式：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230630094926759-169113200028544.png" alt="image-20230630094926759"></p><p>​方法调用：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230630095003785-169113200028543.png" alt="image-20230630095003785"></p><p>方法先定义再调用。否则报错</p><p>类似于C语言中的定义函数</p><hr><p><strong>带参数的方法定义</strong></p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230630100449372-169113200028546.png" alt="image-20230630100449372"></p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230630100558731-169113200028545.png" alt="image-20230630100558731"></p><p>带参数的方法定义</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230630100652371-169113200028547.png" alt="image-20230630100652371"></p><p>变量名或常量值</p><p><strong>注意：</strong></p><p>参数的数量与类型必须与方法定义中的设置相匹配，否则报错</p><hr><p><strong>形参和实参</strong></p><p>传过去的为实参，接收的为形参</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230630101204111-169113200028548.png" alt="image-20230630101204111"></p><hr><p>带返回值方法的定义和调用</p><p>带返回值方法定义</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230630103708672-169113200028549.png" alt="image-20230630103708672"></p><p>带返回值方法的调用</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230630103929464-169113200028550.png" alt="image-20230630103929464"></p><hr><p>方法的注意事项</p><ul><li>方法不能嵌套定义</li><li>void表示无返回值，可以圣罗return，或者后面不跟数据。</li></ul><hr><p>方法的通用格式</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230630105029457-169113200028551.png" alt="image-20230630105029457"></p><p>定义中，要做到<em><strong>两个明确</strong></em></p><ul><li>明确返回值类型：主要是明确方法操作完毕后是否有返回值，如果没有写void；如果有，写对应的数据类型</li><li>明确参数：主要是明确参数的类型和数量</li></ul><p>调用方法时：</p><p>​void类型的方法，直接调用即可</p><p>​非void类型的方法，推荐用变量接收调用</p><hr><h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><p>方法重载指同一个类中定义的多个方法之间的关系，满足下列条件的多个方法相互构成重载</p><ul><li>多个方法在同一个类中</li><li>多个方法具有相同的方法名</li><li>多个方法的参数不相同，类型不同或者数量不同</li></ul><p>特点：</p><ul><li>重载仅对应方法的定义，与方法的调用无关，调用方式参照标准格式</li><li>重载仅仅针对同一个类中方法的名称与参数进行识别，<strong>与返回值无关</strong>，换句话说不能通过返回值来判定两个方法是否相互构成重载</li></ul><p> <em><strong>在调用的时候，Java虚拟机会通过参数的不同来区分同名的方法</strong></em></p><p>ps：我觉得方法重载主要是 功能大致相同以及兼容其余类型的时候使用多个同名方法来构成重载</p><hr><h3 id="方法参数传递"><a href="#方法参数传递" class="headerlink" title="方法参数传递"></a>方法参数传递</h3><p>基本类型</p><p>对于基本数据类型的参数，形式参数的改变，不影响实际参数的值</p><p>引用类型</p><p>对于引用类型的参数，形式参数的改变，影响实际参数的值</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230630113319633-169113200028552.png" alt="image-20230630113319633"></p><p>举例数组，数组是以地址存储，为引用类型</p><hr><h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><p>调试工具，它可以用于<strong>查看程序</strong>的<strong>执行流程</strong>，也可以追踪程序执行过程来<strong>调试程序</strong></p><p>又称为断点调试，断点是一个标记，告诉从哪里开始查看</p><ol><li><p>如何加断点</p><p>行号后面点击即可 一个红点</p></li><li><p>如何运行加了断点的程序</p><p>代码区右键Debug运行</p></li><li><p>看哪里</p><p>看Debugger窗口，还要看Console窗口</p></li><li><p>点哪里</p><p>按F7，或者点Step Into 步进按钮 图标为一个向下箭头 最后左边方块Stop结束</p></li><li><p>如何删除断点</p><p>选择删除断点，单击即可  多个断也可一键删除</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230630115743149-169113200028554.png" alt="image-20230630115743149"></p></li></ol><p>debug调试从断点开始一步一步往下执行，显示执行过程与相应变化</p><p>碰见键盘输入值 则需输入否则无法继续运行</p><p>导包：</p><ol><li>手动导包  自己输入</li><li>快捷键导包 Alt+Enter </li><li>自动导包  输入的时候有提示就可以自动导入</li></ol><h2 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h2><h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><p>对象是具体的，类是抽象的</p><ul><li>类是对象的数据类型</li><li>类是具有相同属性和行为的一组对象的集合</li><li>属性：对象具有的各种特征，每个对象的每个属性都拥有特定的值</li><li>行为：对象能够执行的操作</li></ul><h3 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h3><p>类的重要西行：是java程序的基本组成单位</p><p>类的组成：<strong>属性</strong>和<strong>行为</strong></p><ul><li>属性：在类中通过<strong>成员变量</strong>来体现(类中方法外的变量)</li><li>行为：在类中通过<strong>成员方法</strong>来体现(和前面的方法去掉static关键字即可)</li></ul><p>类的定义</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230630164100847-169113200028553.png" alt="image-20230630164100847"></p><p>范例：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230630164356730-169113200028556.png" alt="image-20230630164356730"></p><h3 id="对象的使用"><a href="#对象的使用" class="headerlink" title="对象的使用"></a>对象的使用</h3><p>创建对象</p><ul><li>类名 对象名 = new 类名()；</li><li>范例 Phone p = new Phone();</li></ul><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230630165016576-169113200028555.png" alt="image-20230630165016576"></p><hr><h3 id="对象内存图"><a href="#对象内存图" class="headerlink" title="对象内存图"></a>对象内存图</h3><h4 id="单个对象内存图"><a href="#单个对象内存图" class="headerlink" title="单个对象内存图"></a>单个对象内存图</h4><h4 id="多个对象内存图"><a href="#多个对象内存图" class="headerlink" title="多个对象内存图"></a>多个对象内存图</h4><p>创建两个对象地址值不相同 分别对应各自创建的对象地址</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230630171901519-169113200028558.png" alt="image-20230630171901519"></p><hr><h4 id="多个对象指向相同"><a href="#多个对象指向相同" class="headerlink" title="多个对象指向相同"></a>多个对象指向相同</h4><p>多个指向一个地址  其中一个改变 则值都改变 因为不是new出来的新的  都是共用一个 所以修改操作都可以</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230630172348593-169113200028560.png" alt="image-20230630172348593"></p><hr><h3 id="成员变量和局部变量"><a href="#成员变量和局部变量" class="headerlink" title="成员变量和局部变量"></a>成员变量和局部变量</h3><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230630172704461-169113200028559.png" alt="image-20230630172704461"></p><p>​<strong>区别：</strong></p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230630172918887-169113200028557.png" alt="image-20230630172918887"></p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><h4 id="private关键字"><a href="#private关键字" class="headerlink" title="private关键字"></a>private关键字</h4><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230630173510280-169113200028561.png" alt="image-20230630173510280"></p><p>为防止数据隐患</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230630174033764-169113200028562.png" alt="image-20230630174033764"></p><p>可以把数据设置为private 然后public方法来控制设置和读取  设置一些判断数据合格的限制，就可以防止数据隐患  以防止调用方数据错误</p><hr><h4 id="private关键字的使用"><a href="#private关键字的使用" class="headerlink" title="private关键字的使用"></a>private关键字的使用</h4><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230630174427883-169113200028563.png" alt="image-20230630174427883"></p><hr><h4 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h4><ul><li>this修饰的变量用于指代成员变量</li><li>this.name = name    前面是成员变量后面是局部变量 </li><li>方法的形参如果与成员变量同名，不带this修饰的变量指的是形参，而不是成员变量</li><li>方法的形参没有与成员变量同名，不带this修饰的变量指的是成员变量</li></ul><p>​什么时候使用this呢？<em><strong>解决局部变量隐藏成员变量</strong></em>  同名</p><p>this：代表所在类的对象引用</p><ul><li>记住：方法被哪个对象调用，this就代表哪个对象</li></ul><hr><h4 id="this内存原理"><a href="#this内存原理" class="headerlink" title="this内存原理"></a>this内存原理</h4><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230630203425240-169113200028565.png" alt="image-20230630203425240"></p><hr><h4 id="封装-1"><a href="#封装-1" class="headerlink" title="封装"></a>封装</h4><ol><li><p>封装概述</p><p>是面向对象三大特征之一(封装，继承，多态)</p><p>是面向对象编程语言对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界是无法直接操作的</p></li><li><p>封装原则</p><p>将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过这类提供的方法来实现对隐藏信息的操作和访问成员变量<em><strong>private</strong></em>，提供对应的***getXxx()/setXxx()***方法</p></li><li><p>封装好处</p><p>通过方法来控制成员变量的操作，提高了代码的安全性</p><p>把代码用方法进行封装，提高了代码的复用性</p></li></ol><hr><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>构造方法是一种特殊的方式</p><p>作用：创建对象</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230630210158146-169113200028564.png" alt="image-20230630210158146"></p><p>当调用这种对象的时候  构造方法就会执行  </p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230630211044610-169113200028566.png" alt="image-20230630211044610"></p><p>调用s.show()； 那个构造会执行</p><p> 它跟别的方法不一样 它格式不同而且后面不是定义的方法名 而是类名来当构造方法名</p><hr><p><em><strong>构造方法的注意事项</strong></em></p><p>可以定义多个构造方法  分为无参构造方法和有参构造方法，有参数的在new类的时候输入参数</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230630212357423-169113200028567.png" alt="image-20230630212357423"></p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230630212407032-169113200028568.png" alt="image-20230630212407032"></p><p><em><strong>重载形式</strong></em></p><ol><li>构造方法的创建<ul><li>如果没有定义构造方法，系统将给出一个<strong>默认</strong>的<strong>无参数构造方法</strong></li><li>如果定义了构造方法，系统将不再提供默认的构造方法</li></ul></li><li>构造方法的重载<ul><li>弱国自定义了带参构造方法，还要使用无参数构造方法，就必须写一个无参数构造方法</li></ul></li><li>推荐的使用方法<ul><li><em><strong>无论是否使用，都手工书写无参数构造方法</strong></em></li></ul></li></ol><hr><h4 id="标准类的制作"><a href="#标准类的制作" class="headerlink" title="标准类的制作"></a>标准类的制作</h4><ol><li>成员变量<ul><li>使用<strong>private</strong>修饰</li></ul></li><li>构造方法<ul><li>提供一个无参构造方法</li><li>提供一个带多个参数的构造方法</li></ul></li><li>成员方法<ul><li>提供每一个成员变量对应的<strong>setXxx()/getXxx()</strong></li><li>提供一个显示对象信息的<strong>show()</strong></li></ul></li><li>创建对象并因为其成员变量赋值的两种方式<ul><li>无参构造方法创建对象后使用**setXxx()**赋值</li><li>使用带参构造方法直接创建带有属性值的对象</li></ul></li></ol><hr><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><p>API概述</p><p>API (<strong>A</strong>pplication <strong>P</strong>rogramming <strong>i</strong>nterface)：应用程序编程接口</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230630214512329-169113200028569.png" alt="image-20230630214512329"></p><p>帮助文档的使用</p><p>可以查看api用法</p><p><strong>API使用练习</strong></p><p>查找文档学习Scanner用法，来实现用键盘输入字符串</p><p>nextLine()；  写一个这个 然后点 Ctrl + Alt + V 可以生成左式子  </p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230630220138368-169113200028570.png" alt="image-20230630220138368"></p><hr><h4 id="Sting"><a href="#Sting" class="headerlink" title="Sting"></a>Sting</h4><p>String类在java.lang包下，所以使用的时候不需要导包</p><p><strong>String</strong>类代表<strong>字符串</strong>，Java程序中的所有字符串文字(例如”abc“)都被实现为该类的实例 也就是说，<strong>Java程序中所有的双引号字符串，都是String类的对象</strong></p><ol><li><strong>字符串的特定</strong></li></ol><ul><li>字符串不可变，它们的值在创建后不能更改</li><li>虽然String的值不可变，但是它们可以被共享</li><li>字符串效果上相当于字符数组(char[])，但是底层逻辑是字节数组(byte[])</li></ul><ol start="2"><li><strong>String的构造方法</strong></li></ol><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230701071600291-169113200028571.png" alt="image-20230701071600291"></p><p>字节数组 为字母ASCII码 转换成字符来输出  </p><p>推荐使用直接赋值的方式得到字符串对象</p><hr><p><strong>字符串对象的特点</strong></p><ol><li>通过new创建的字符串对象，每一次new都会申请一个内存空间，虽然内容相同，但是地址值不同</li><li>以 ”“ 给出的字符串，只要字符序列相同(顺序和大小写)，无论程序代码出现几次，JVM都只会建立一个String对象，并在字符串池中维护</li></ol><hr><p><strong>字符串的比较</strong></p><p>使用 == 比较</p><ul><li>基本类型：比较的是<strong>数据值</strong>是否相同</li><li>引用类型：比较的是<strong>地址值</strong>是否相同</li></ul><p> <img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230701080248910-169113200028572.png" alt="image-20230701080248910"></p><p>字符串比较用equals()方法</p><p>s1.equals(s2);   </p><hr><p><strong>遍历字符串</strong></p><p>思路与数组相似</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230701095300478-169113200028673.png" alt="image-20230701095300478"></p><p>charAt(int index)方法  获取字符串中的每一个字符</p><p>length()   获得字符串长度</p><hr><p><strong>字符串拼接</strong></p><p><strong>字符串反转</strong></p><p><strong>帮助文档查看String方法</strong></p><hr><h5 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a><em><strong>StringBuilder</strong></em></h5><p>StringBuilder 是一个可变的字符串类，我们可以把它看成是一个容器</p><p>这里的可变指的是StringBuilder对象中的容器是可变的</p><p>String和StringBuilder的区别：</p><ul><li>String：内容是不可变的</li><li>StringBuilder：内容是可变的</li></ul><hr><p><strong>StringBuilder构造方法</strong></p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230701104728946-169113200028675.png" alt="image-20230701104728946"></p><hr><p><strong>StringBuilder的添加和反转方法</strong></p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230701105132689-169113200028674.png" alt="image-20230701105132689"></p><p>append()；方法</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230701110311777-169113200028677.png" alt="image-20230701110311777"></p><p>返回来是对象本身就可以再调，链式编程</p><p>reverse()；方法</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230701110705676-169113200028676.png" alt="image-20230701110705676"></p><p>直接反转字符串</p><hr><h5 id="StringBuilder和String相互转换"><a href="#StringBuilder和String相互转换" class="headerlink" title="StringBuilder和String相互转换"></a><em><strong>StringBuilder和String相互转换</strong></em></h5><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230701110934286-169113200028680.png" alt="image-20230701110934286"></p><p>toString()                        StringBuilder转为String</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230701112528175-169113200028679.png" alt="image-20230701112528175"></p><p>StringBuilder(String s)  构造方法     String转为StringBuilder</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230701112754069-169113200028678.png" alt="image-20230701112754069"></p><p><strong>通过帮助文档查看StringBuilder中的方法</strong></p><hr><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p>编程存取多个数据，使用长度固定的数据存储格式，不一定满足需求，</p><p>集合类的特点：提供一种存储空间可变的存储模型，存储的数据容量可以发生改变</p><p>ArrayList就是其中一个集合类</p><p>ArrayLIst &lt; E &gt; :</p><ul><li>可调整大小的数组实现</li><li>&lt; E &gt; ：是一种特殊的数据类型，泛型。</li></ul><p>用法：</p><p>在 E 的地方使用引用数据类型替换即可</p><p>范例：ArrayList &lt; String &gt;, ArrayList &lt; Student &gt;</p><hr><p><strong>ArrayList构造方法和添加方法</strong></p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230701142041239-169113200028682.png" alt="image-20230701142041239"></p><p>如何使用：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230701143411592-169113200028681.png" alt="image-20230701143411592"></p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230701143430857-169113200028685.png" alt="image-20230701143430857"></p><hr><p><em><strong>ArrayList集合常用方法</strong></em></p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230701143641224-169113200028683.png" alt="image-20230701143641224"></p><p>空集合默认为[]</p><p>像指定索引处插入元素，此位置及后面元素后移</p><p><strong>存储字符串并遍历</strong></p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230701145501167-169113200028684.png" alt="image-20230701145501167"></p><p><strong>存储学生对象并遍历</strong></p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230701151214609-169113200028687.png" alt="image-20230701151214609"></p><hr><p><strong>存储学生对象并遍历升级版</strong></p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230701154116779-169113200028688.png" alt="image-20230701154116779"></p><hr><h3 id="学生管理系统"><a href="#学生管理系统" class="headerlink" title="学生管理系统"></a>学生管理系统</h3><p><em><strong>Alt+insert  组合 根据自己需要选择  可以生成构造方法  效率</strong></em></p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230701155803685-169113200028686.png" alt="image-20230701155803685"></p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230701154242193-169113200028689.png" alt="image-20230701154242193"></p><p>项目操作。</p><hr><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承是面向对象三大特征之一。可以使得子类具有父类的属性和方法，还可以在子类中重新定义，追加属性和方法。</p><p><strong>继承的格式</strong></p><ul><li>格式：public class 子类名 <em><strong>extends</strong></em> 父类名 { }</li><li>范例：public class Zi <em><strong>extends</strong></em> Fu { }</li><li>Fu：是父类，也被称为基类、超类</li><li>Zi：是子类，也被成为派生类</li></ul><p><strong>继承中子类的特点</strong></p><ul><li>子类可以有父类的内容</li><li>子类还可以有自己特有的内容</li></ul><p><strong>继承的好处和弊端</strong></p><p>继承好处</p><ul><li>提高了代码的<strong>复用性</strong>(多个类形同的成员可以放在同一个类中)</li><li>提高了代码的<strong>维护类</strong>(如果方法的代码需要修改，修改一处即可)</li></ul><p>继承弊端</p><ul><li>继承让类与类之间产生了关系，类的耦合性增强了，当父类发生变化时子类也不得不跟着变化，削弱了子类的独立性</li></ul><p><strong>什么时候使用继承？</strong></p><ul><li>继承体现的关系：<em><strong>is a</strong></em></li><li>假设法：我有两个类A和B，如果他们满足A是B的一种，就说明他们存在继承关系，这个时候就可以考虑继承来体现，否则就不能滥用继承</li><li>举例：苹果和水果，猫和动物，//  猫和狗  这两个不能说成谁是谁的一种 所以不存在继承关系</li></ul><p><strong>继承中变量的访问特点</strong></p><p>在子类方法中访问一个变量</p><ul><li>先在子类局部范围找</li><li>子类成员范围找</li><li>父类成员范围找</li><li>如果都没有就报错(不考虑父亲的父亲…)</li></ul><h4 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h4><p><strong>super可以直接访问父类成员变量。</strong></p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230701202156548-169113200028690.png" alt="image-20230701202156548"></p><p><strong>总结</strong></p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230701202524044-169113200028691.png" alt="image-20230701202524044"></p><p><strong>继承中构造方法的访问特点</strong></p><p>子类中所有的构造方法默认都会访问父类中无参的构造方法</p><p>问什么呢？</p><ul><li>因为子类会继承父类中的数据，可能还会使用父类的数据。所以，子类初始化之前，一定要先完成父类数据的初始化</li><li>每一个子类构造方法的第一句语句默认都是：<em><strong>super()</strong></em></li></ul><p>如果父类中没有无参构造方法，只有带参构造方法，该怎么办？</p><ul><li>通过使用super关键字去显示的调用父类的带参构造方法</li><li>在父类中自己提供一个无参构造方法</li></ul><p><em><strong>推荐：自己给出无参构造方法</strong></em></p><hr><p><strong>继承中成员方法的访问特点</strong></p><p>通过子类对象访问一个方法</p><ul><li>子类成员范围找</li><li>父类成员范围找</li><li>富国都没有就报错(不考虑父亲的父亲…)</li></ul><hr><p><em><strong>Super内存图</strong></em></p><p><a href="https://www.bilibili.com/video/BV18J411W7cE?p=156&amp;spm_id_from=pageDriver&amp;vd_source=9d1aa011fa5cf2a5daae2b2d89f5da91">007_super内存图_哔哩哔哩_bilibili</a></p><hr><h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><p>概述</p><ul><li>子类中出现了和父类中一模一样的方法声明</li></ul><p>方法重写的应用</p><ul><li>当子类需要父类的功能，而功能主体子类有自己特有的内容时，可以重写父类中的方法，这样，即沿袭了父类的功能，又定义了子之类特有的内容</li></ul><p>重写过程中容易把方法声明写错</p><p>为了帮助检验， 在上面写上 <em><strong>@Override</strong></em> 注解 表明下面的方法时重写父类的</p><p>当**@Override**报错则下面方法重写有错误</p><p><em><strong>@Override</strong></em></p><ul><li>是一个注解(注解后面会学习到)</li><li>可以帮助我们检查重写方法的方法声明的正确性</li></ul><p><em><strong>方法重写注意事项</strong></em></p><ul><li>私有方法不能被重写(父类私有成员 子类是不能继承的)</li><li>子类方法访问权限不能更低(public &gt; 默认 &gt; private)</li></ul><hr><p><strong>Java中继承的注意事项</strong></p><ul><li>Java中类只支支持单继承，不支持多继承</li><li>Java中类支持多层继承</li></ul><p>单继承指的是一个类只能继承一个类，多层继承 可以继承的父类再继承一个类</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230703070450344-169113200028693.png" alt="image-20230703070450344"></p><p>默认无参构造方法，有带参构造方法后，则不执行默认，需要手动创建无参构造方法</p><hr><h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><h5 id="包"><a href="#包" class="headerlink" title="包"></a>包</h5><p>包就是文件夹，方便对类进行分类管理</p><p>包的定义格式</p><ul><li>格式：package包名；(多级包用 . 分开)</li><li>范例：package com.itheima;</li></ul><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230703082026375-169113200028692.png" alt="image-20230703082026375"></p><p>命令提示符 自动创建包的路径  运行时带上包的路径 也可手动建立包</p><p>在IDEA左边新建项目 新建模块  在模块下src 新建包   新建java类 然后编译运行 方便</p><h5 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h5><p>用其余包中的类 需要在前面加上包名     过于繁琐需要每次加包名</p><p>或者<strong>import 包路径</strong>来导入  范例：impot cn.itcaset.Teacher </p><p> import java.util.Scanner / Random  也是导包操作</p><hr><h5 id="修饰符-1"><a href="#修饰符-1" class="headerlink" title="修饰符"></a>修饰符</h5><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230703085604984-169113200028694.png" alt="image-20230703085604984"></p><hr><h5 id="状态修饰符"><a href="#状态修饰符" class="headerlink" title="状态修饰符"></a>状态修饰符</h5><ol><li><p><strong>final</strong> (最终态)</p><p><strong>final</strong>关键字是最终的意思，可以修饰成员方法，成员变量，类</p><p>final为最终的意思   </p><ul><li><p><strong>final</strong>修饰的特点：</p><p>修饰方法：表明该方法是最终方法，<strong>不能被重写</strong></p><p>修饰变量：表明该变量是常量，<strong>不能再次被赋值</strong></p><p>修饰类：表明该类是最终类，不能被继承</p></li><li><p><strong>final</strong>修饰局部变量</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230703091334421-169113200028695.png" alt="image-20230703091334421"></p></li></ul></li><li><p><strong>static</strong> (静态)</p><p><strong>static</strong>关键字是静态的意思，可以修饰成员方法，成员变量</p><p><strong>static</strong>修饰的特点</p><ul><li><p>被类的所有对象共享<br>这也是我们判断是否使用静态关键字的条件</p></li><li><p>可以通过类名调用</p><p>当然，也可以通过对象名调用</p><p><strong>推荐使用类名调用</strong></p></li></ul><p><strong>static</strong>访问特点</p><p>非静态的成员方法</p></li></ol><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230703092600121-169113200028696.png" alt="image-20230703092600121"></p><p>​静态的成员方法</p><p>​<img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230703092722511-169113200028697.png" alt="image-20230703092722511"></p><p>​<em><strong>总结成一句话就是：静态成员方法只能访问静态成员</strong></em></p><hr><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h4><p>同一个对象，在不同时刻表现出来的不同状态</p><p>举例：猫</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230703100359983-169113200028698.png" alt="image-20230703100359983"></p><p>多态的前提和体现</p><ul><li>有继承/实现关系</li><li>有方法重写</li><li>有父类引用指向子类对象</li></ul><h4 id="多态中成员访问特点"><a href="#多态中成员访问特点" class="headerlink" title="多态中成员访问特点"></a><strong>多态中成员访问特点</strong></h4><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230703104726179-1691132000286100.png" alt="image-20230703104726179"></p><h4 id="多态的好处和弊端"><a href="#多态的好处和弊端" class="headerlink" title="多态的好处和弊端"></a>多态的好处和弊端</h4><ul><li><p>多态的好处：提高了程序的扩展性</p><p>​具体体现：定义方法的时候，使用父类型作为参数，将来在使用的时候，使用具体的子类型参与操作</p></li><li><p>多态的弊端：不能使用子类的特有功能</p></li></ul><h4 id="多态中的转型"><a href="#多态中的转型" class="headerlink" title="多态中的转型"></a>多态中的转型</h4><ul><li><p>向上转型</p><p>​从子到父</p><p>​父类引用指向子类对象</p></li><li><p>向下转型</p><p>​从父到子</p><p>​父类引用转为子类对象</p></li></ul><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230703110830225-1691132000286101.png" alt="image-20230703110830225"></p><h4 id="多态转型内存图解"><a href="#多态转型内存图解" class="headerlink" title="多态转型内存图解"></a>多态转型内存图解</h4><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230703111516872-169113200028699.png" alt="image-20230703111516872"></p><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>抽象类概述</p><p>在Java中，一个<strong>没有方法体</strong>的方法应该定义为<strong>抽象方法</strong>，而类中如果有<strong>抽象方法</strong>，该类必须定义为<strong>抽象类</strong></p><h5 id="abstract关键字"><a href="#abstract关键字" class="headerlink" title="abstract关键字"></a><strong>abstract</strong>关键字</h5><p>abstract关键字来说明抽象类抽象方法</p><h5 id="抽象类的特点"><a href="#抽象类的特点" class="headerlink" title="抽象类的特点"></a><strong>抽象类的特点</strong></h5><ul><li><p>抽象类和抽象方法必须使用<strong>abstract</strong>关键字修饰</p><p>public <strong>abstract</strong> class 类名 {}</p><p>public <strong>abstract</strong> void eat()；</p></li><li><p>抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类</p></li><li><p>抽象类不能实例化</p><p>抽象类如何实例化呢？参照多态的方式，通过子类对象实例化，这叫抽象类多态</p></li><li><p>抽象类的子类</p><p>要么重写抽象类中的所有抽象方法</p><p>要么是抽象类</p></li></ul><h5 id="抽象类的成员特点"><a href="#抽象类的成员特点" class="headerlink" title="抽象类的成员特点"></a>抽象类的成员特点</h5><ul><li><p>成员变量</p><p>可以是变量</p><p>也可以是常量</p></li><li><p>构造方法</p><p>有构造方法，但是不能实例化</p><p>那么，构造方法的作用是什么呢？ 用于子类访问父类数据的初始化 </p></li><li><p>成员方法</p><p>可以有抽象方法：限定子类必须完成某些动作</p><p>也可以有非抽象方法：提高代码复用性</p></li></ul><hr><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>接口就是一种<strong>公共的规范标准</strong>，只要符合规范标准，大家都可以通用</p><p>Java中的接口更多的体现在<em><strong>对行为的抽象</strong></em></p><h5 id="接口的特点"><a href="#接口的特点" class="headerlink" title="接口的特点"></a>接口的特点</h5><ul><li><p>接口用关键字interface修饰</p><p>public <strong>interface</strong> 接口名 { }</p></li><li><p>类实现接口用implements表示</p><p>public class 类名 <strong>implements</strong> 接口名 { }</p></li><li><p>接口不能实例化</p><p>接口如何实例化呢？参照多态的方式，通过实现类对象实例化，这叫接口多态。</p><p>多态的形式：具体类多态，<em><strong>抽象类多态，接口多态</strong></em>  (用的多)</p><p>多态的前提：有继承或者实现关系；有方法重写；有父(类/接口)引用指向(子/实现)类对象</p></li><li><p>接口的实现类</p><p>要么重写接口中的所有抽象方法</p><p>要么是抽象类</p></li></ul><hr><h5 id="接口的成员特点"><a href="#接口的成员特点" class="headerlink" title="接口的成员特点"></a>接口的成员特点</h5><ul><li><p>成员变量</p><p>只能是常量</p><p>默认修饰符： public static final</p></li><li><p>构造方法</p><p>接口没有构造方法，因为接口主要是对行为进行抽象，是没有具体存在</p><p>一个类如果没有父类，默认继承自Object类</p></li><li><p>成员方法</p><p>只能是抽象方法</p><p>默认修饰符：public abstract</p><p>关于接口中的方法，JDK8和JDK9中有一些新特性，后面有讲解</p></li></ul><hr><h4 id="类和接口的关系"><a href="#类和接口的关系" class="headerlink" title="类和接口的关系"></a>类和接口的关系</h4><ul><li><p>类和类的关系</p><p>继承关系，只能单继承，但是可以多层继承 </p></li><li><p>类和接口的关系</p><p>实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口</p></li><li><p>接口和接口的关系</p><p>继承关系，可以单继承，也可以多继承</p></li></ul><hr><p>抽象类和接口的区别</p><ul><li><p>成员区别</p><p>抽象类变量，常量；有构造方法；有抽象方法，也有非抽象方法</p><p>接口常量；抽象方法</p></li><li><p>关系区别</p><p>类与类继承，单继承</p><p>类与接口实现，可以单实现，也可以多实现</p><p>接口与接口继承，单继承，多继承</p></li><li><p>设计理念区别</p><p>抽象类对类抽象，包括属性，行为</p><p>接口对行为抽象，主要是行为</p></li></ul><p>抽象类是对事物的抽象，而接口是对行为的抽象</p><hr><h3 id="形参和返回值"><a href="#形参和返回值" class="headerlink" title="形参和返回值"></a>形参和返回值</h3><p><strong>类名作为形参和返回值</strong></p><ul><li>方法的形参是类名，其实需要的是该类的对象</li><li>方法的返回值是类名，其实返回的是该类的对象</li></ul><p><strong>抽象类名作为形参和返回值</strong></p><ul><li>方法的形参是抽象类名，其实需要的是该抽象类的子类对象</li><li>方法的返回值是抽象类名，其实返回的是该抽象类的子类对象</li></ul><p><strong>接口名作为形参和返回值</strong></p><ul><li>方法的形参是接口名，其实需要的是该接口的实现类对象</li><li>方法的返回值是接口名，其实返回的是该接口的实现类对象</li></ul><hr><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>内部类：就是在一个类中定义一个类。举例：在一个类A的内部定义一个类B,类B就被成为内部类</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230703190242029-1691132000286102.png" alt="image-20230703190242029"></p><p>内部类的访问特点：</p><ul><li>内部类可以直接访问外部类的成员，包括私有</li><li>外部类要访问内部类的成员，必须创建对象</li></ul><h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a><strong>成员内部类</strong></h4><ul><li>在类的成员位置：成员内部类</li><li>在类的局部位置：局部内部类</li></ul><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230703191846909-1691132000286103.png" alt="image-20230703191846909"></p><p>常用用途可能为下图这种  内部类通常来隐藏不让直接访问 通过间接调用来访问</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230703193109073-1691132000286105.png" alt="image-20230703193109073"></p><hr><h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a><strong>局部内部类</strong></h4><p>局部内部类是在方法中定义的类，所以外界是无法直接使用，需要在方法内部创建对象并使用</p><p>该类可以直接访问外部类的成员，也可以访问方法内的局部变量</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230703194010594-1691132000286104.png" alt="image-20230703194010594"></p><hr><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a><strong>匿名内部类</strong></h4><p>前提：存在一个类或者接口，这里的类可以是具体类也可以是抽象类</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230703195428095-1691132000286106.png" alt="image-20230703195428095"></p><p> <strong>局部内部类的特殊形式</strong>所以得写在方法中</p><p>可以直接在末尾调用内部的方法。</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230703201131161-1691132000287107.png" alt="image-20230703201131161"></p><hr><p><em><strong>匿名内部类在开发中的使用</strong></em></p><p> 可以避免频繁创建新的类</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230703213216337-1691132000287108.png" alt="image-20230703213216337"></p><hr><h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><p>java.lang  不用导包  所有类直接或者间接继承Object类</p><p>查看帮助文档可以详细查看</p><p>Math包含执行基本数字运算的方法</p><p><strong>没有构造方法，如何使用类中的成员呢？</strong></p><p>看类的成员<em><strong>是否都是静态的，如果是，通过类名就可以直接调用</strong></em></p><p><strong>常用方法</strong></p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230703214711330-1691132000287109.png" alt="image-20230703214711330"></p><hr><h3 id="System"><a href="#System" class="headerlink" title="System"></a>System</h3><p>System包含几个有用的类字段，它不能被实例化，成员方法我为静态的，<strong>通过类名可以直接调用</strong></p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704071157925-1691132000287110.png" alt="image-20230704071157925"></p><p>currentTimeMillis()的两种用法</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704072320039-1691132000287112.png" alt="image-20230704072320039"></p><hr><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p>Obeject是类层次结构的根，每个类都可以将Object作为超类。所有类都直接或者间接的继承自该类</p><p>构造方法：public Object()</p><p>为什么说子类的构造方法默认访问的是父类的无参构造方法？</p><p>因为它们的顶级父类只有无参构造方法</p><p><strong>看方法的源码，选中方法，按下Ctrl+B</strong>   |    <strong>选中方法 右键  Go To  选declaration</strong></p><p>Object中的toString()方法输入对象地址信息，建议重写此方法  自动生成即可</p><p>Alt+insert即可自动生成</p><p><em><strong>Object类的常用方法</strong></em></p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704080531869-1691132000287111.png" alt="image-20230704080531869"></p><hr><h3 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h3><p>冒泡排序</p><p><strong>Arryas类的概述和常用方法</strong></p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704085743250-1691132000287113.png" alt="image-20230704085743250"></p><p> <img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704090152654-1691132000287114.png" alt="image-20230704090152654"></p><hr><h3 id="基本类型包装类"><a href="#基本类型包装类" class="headerlink" title="基本类型包装类"></a>基本类型包装类</h3><p>将<em><strong>基本数据类型封装成对象</strong></em>的好处在于可以在对象中定义更多的功能方法操作该数据</p><p>常用操作之一：<strong>用与基本数据类型与字符串之间的转换</strong></p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704091848513-1691132000287115.png" alt="image-20230704091848513"></p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704092011550-1691132000287116.png" alt="image-20230704092011550"></p><p>除了 int  -&gt; Integer    跟   char -&gt; Character  其余都是首字母大写</p><hr><h3 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h3><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704092618582-1691132000287118.png" alt="image-20230704092618582"></p><p>第二个String s 为数值类型的字符串</p><p>推荐使用下面两个静态方法 可以不用new一个实例，直接类名调用</p><hr><p>int  和  String 的相互转换</p><p>基本类型包装类的最常见操作就是：用于基本类型和字符串之间的相互转换</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704105050581-1691132000287117.png" alt="image-20230704105050581"></p><hr><h4 id="Int-转换为-String"><a href="#Int-转换为-String" class="headerlink" title="Int 转换为 String"></a><strong>Int 转换为 String</strong></h4><p>public static String **valueOf(int i)**：返回int参数的字符串表示形式。该方法是String类中的方法</p><h4 id="String转换为-int"><a href="#String转换为-int" class="headerlink" title="String转换为 int"></a><strong>String转换为 int</strong></h4><p>public static int **parseint(String s)**：将字符串解析为int类型。该方法是interger类中的方法</p><hr><h4 id="字符串中数据排序"><a href="#字符串中数据排序" class="headerlink" title="字符串中数据排序"></a><strong>字符串中数据排序</strong></h4><p>此程序中用到了字符串的split方法</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704111706126-1691132000287119.png" alt="image-20230704111706126"></p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704111714185-1691132000287121.png" alt="image-20230704111714185"></p><hr><h3 id="自动装箱和拆箱"><a href="#自动装箱和拆箱" class="headerlink" title="自动装箱和拆箱"></a>自动装箱和拆箱</h3><ul><li>装箱：把基本数据类型转换为对应的包装类类型</li><li>拆箱：把包装类类型转换为对应的基本数据类型</li></ul><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704112214597-1691132000287120.png" alt="image-20230704112214597"></p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704112255298-1691132000287122.png" alt="image-20230704112255298"></p><p>注意注意注意</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704112323799-1691132000287123.png" alt="image-20230704112323799"></p><hr><h3 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h3><p>Data代表了一个特定的时间，精确到毫秒</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704112554025-1691132000287124.png" alt="image-20230704112554025"></p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704112824095-1691132000287126.png" alt="image-20230704112824095"></p><p><em><strong>Data类的常用方法</strong></em></p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704112930626-1691132000287125.png" alt="image-20230704112930626"></p><h3 id="SimpleDateFormat类"><a href="#SimpleDateFormat类" class="headerlink" title="SimpleDateFormat类"></a><strong>SimpleDateFormat类</strong></h3><p>SimpleDateFormat是一个具体的类，用于以区域设置敏感的方法格式化和解析日期。<strong>重点学习日期格式化和解析</strong></p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704113924636-1691132000287127.png" alt="image-20230704113924636"></p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704113937967-1691132000287128.png" alt="image-20230704113937967"></p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704114747410-1691132000287129.png" alt="image-20230704114747410"></p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704114636246-1691132000287130.png" alt="image-20230704114636246"></p><p>为了不报错  解析要与设定的格式相同</p><hr><p><strong>日期工具类</strong></p><p> 创建的工具类</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704135922982-1691132000287132.png" alt="image-20230704135922982"></p><hr><h3 id="Calendar类-日历类"><a href="#Calendar类-日历类" class="headerlink" title="Calendar类  日历类"></a>Calendar类  日历类</h3><p>Calendar为某一时刻和一组日历字段之间的转换提供了一些方法，并为操作日历字段提供了一些方法</p><p>Calendar提供了一个类方法getInstance用于获取Calendar对象，其日历字段已使用当前日期和时间初始化：</p><p>Calendar rightNow = Calendar.getInstance()；</p><p>Calendar 的常用方法</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704143432312-1691132000287131.png" alt="image-20230704143432312"></p><p> get add set方法示例</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704144003067-1691132000287133.png" alt="image-20230704144003067"></p><hr><h4 id="二月天案例"><a href="#二月天案例" class="headerlink" title="二月天案例"></a>二月天案例</h4><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704150843415-1691132000287134.png" alt="image-20230704150843415"></p><p><strong>注意</strong> 月份从0开始记  所以三月值为2</p><hr><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>概述</p><p>就是程序出现了不正常的情况</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704152127429-1691132000287137.png" alt="image-20230704152127429"></p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704152143063-1691132000287135.png" alt="image-20230704152143063"></p><hr><h3 id="JVM的默认处理方案"><a href="#JVM的默认处理方案" class="headerlink" title="JVM的默认处理方案"></a>JVM的默认处理方案</h3><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704152358459-1691132000287136.png" alt="image-20230704152358459"></p><hr><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>如果程序出现了问题，我们需要自己来处理，有两种处理方案：</p><ul><li>try … catch …</li><li>throws</li></ul><hr><h4 id="try…catch…"><a href="#try…catch…" class="headerlink" title="try…catch…"></a>try…catch…</h4><ul><li>格式</li></ul><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704152715732-1691132000287138.png" alt="image-20230704152715732"></p><p>示例：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704153022240-1691132000287139.png" alt="image-20230704153022240"></p><p>e是个对象可以调用方法，e.printStackTracec()；这个会把错误信息输出在控制台，与默认方法不同是，不会直接退出程序。</p><hr><h4 id="Throuwable"><a href="#Throuwable" class="headerlink" title="Throuwable"></a>Throuwable</h4><p>Throuwable的成员方法</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704153220597-1691132000288140.png" alt="image-20230704153220597"></p><p>示例：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704153637753-1691132000288142.png" alt="image-20230704153637753"></p><hr><h4 id="编译时异常和运行时异常的区别"><a href="#编译时异常和运行时异常的区别" class="headerlink" title="编译时异常和运行时异常的区别"></a>编译时异常和运行时异常的区别</h4><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704154627084-1691132000288141.png" alt="image-20230704154627084"></p><hr><h4 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h4><p>虽然try…catch…可以对异常进行处理，但是并不是所有异常都有权限进行处理，也就是说，有些时候可能出现的异常是我们处理不了的，这时候就需要throws的处理方式</p><p>格式：</p><p><em><strong>throws 异常类名；</strong></em></p><p><em>注意：</em>这个格式时跟在方法的括号后面的</p><p>示例：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704155929931-1691132000288143.png" alt="image-20230704155929931"></p><ul><li>编译时异常必须要进行处理，两种处理方案：try…catch…或者throws，如果采用throws这种方案，将来谁调用谁来处理</li><li>运行时异常可以不处理，出现问题后，需要我们回来修改代码</li></ul><p>throws仅仅为抛出异常  处理异常还需要try…catch..来处理</p><hr><h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704161109194-1691132000288144.png" alt="image-20230704161109194"></p><p>throw与throws的区别</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704162043546-1691132000288146.png" alt="image-20230704162043546"></p><hr><h2 id="集合进阶"><a href="#集合进阶" class="headerlink" title="集合进阶"></a>集合进阶</h2><p>体系结构</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704162639330-1691132000288145.png" alt="image-20230704162639330"></p><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><p>Collection集合概述</p><ul><li>是单列集合的顶层接口，它表示一组对象，这些对象也称为的Collection的元素</li><li>JDK不提供此接口的任何直接实现，它提供更具体的子接口（如Set和List）实现</li></ul><p>创建Collection集合的对象</p><ul><li>多态的方式</li><li>具体的实现类ArrayList</li></ul><p>范例：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704163143658-1691132000288148.png" alt="image-20230704163143658"></p><p> Collection集合常用方法</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704163250161-1691132000288147.png" alt="image-20230704163250161"></p><p>Alt+7可以打开类的结构窗口 方便查看类中方法定义等</p><hr><h4 id="Collection集合的遍历"><a href="#Collection集合的遍历" class="headerlink" title="Collection集合的遍历"></a><strong>Collection集合的遍历</strong></h4><h5 id="Iterator迭代器"><a href="#Iterator迭代器" class="headerlink" title="Iterator迭代器"></a>Iterator迭代器</h5><p>Iterator：迭代器，集合的专用遍历方式</p><ul><li>Iterator &lt;E&gt;  iterator()  ：返回此集合中元素的迭代器，通过集合的iterator()方法得到</li><li>迭代器是通过集合的iterator()方法得到的，所以我们说它是依赖于集合而存在的</li></ul><p>Iterator中的常用方法</p><ul><li>E  next()：返回迭代中的下一个元素</li><li>boolean hasNext()：如果迭代具有更多的元素，则返回true</li></ul><p> <img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704170107538-1691132000288149.png" alt="image-20230704170107538"></p><p>先得到迭代器对象 </p><p>利用hasNext()来判断是否有元素，然后next()输出</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704170146654-1691132000288150.png" alt="image-20230704170146654"></p><p>这就是Collection集合的 遍历</p><hr><h3 id="集合的使用步骤"><a href="#集合的使用步骤" class="headerlink" title="集合的使用步骤"></a>集合的使用步骤</h3><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704171257916-1691132000288151.png" alt="image-20230704171257916"></p><hr><h3 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h3><p>概述</p><ul><li>有序集合(也称为序列)，用户可以精确控制列表中每个元素的插入位置。用户可以通过整数索引访问元素，并搜索列表中的元素</li><li>与Set集合不同，列表通常允许重复的元素</li></ul><p>List集合特点</p><ul><li>有序：存储和取出的元素顺序一致</li><li>可重复：存储的元素可以重复</li></ul><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704174543679-1691132000288153.png" alt="image-20230704174543679"></p><h4 id="List的特有方法"><a href="#List的特有方法" class="headerlink" title="List的特有方法"></a>List的特有方法</h4><p>Collection集合没有 儿子集合ArrayList有</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704174700576-1691132000288152.png" alt="image-20230704174700576"></p><hr><p>List的两种遍历形式</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704192402780-1691132000288154.png" alt="image-20230704192402780"></p><hr><h4 id="并发修改异常"><a href="#并发修改异常" class="headerlink" title="并发修改异常"></a>并发修改异常</h4><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704193749376-1691132000288155.png" alt="image-20230704193749376"></p><hr><h4 id="Listiterator列表迭代器"><a href="#Listiterator列表迭代器" class="headerlink" title="Listiterator列表迭代器"></a>Listiterator列表迭代器</h4><p>Listiterator：列表迭代器</p><ul><li><p>通过List集合的listIterator()方法得到，所以说它是List集合特有的迭代器</p></li><li><p>用于允许程序员沿任意方向遍历列表的列表迭代器，在迭代期间修改列表，并获取列表中迭代器的当前位置</p></li></ul><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704194301711-1691132000288156.png" alt="image-20230704194301711"></p><p>利用ListInterator 来往集合中添加元素</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704195023104-1691132000288158.png" alt="image-20230704195023104"></p><hr><h3 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h3><p>增强for：简化数组和Collection集合的遍历</p><ul><li>实现Iterable接口允许其对象成为增强类for语句的目标</li><li>它是JDK5之后出现的，其内部原理是一个Iterator迭代器</li></ul><p>增强for的格式</p><ul><li><p>格式：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704195501791-1691132000288157.png" alt="image-20230704195501791"></p></li></ul><p>范例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">:</span> arr<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>范例2：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704200511382-1691132000288159.png" alt="image-20230704200511382"></p><p>只是为了遍历则选择增强for  因为这是最方便的遍历</p><p>如果操作需要索引，只能选择普通for</p><hr><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>数据结构是计算机存储、组织数据的方式。是指相互之间存在一种或多种特定关系的数据元素的集合</p><p>通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率</p><p><em><strong>常见数据结构</strong></em></p><h4 id="常见数据结构之-栈"><a href="#常见数据结构之-栈" class="headerlink" title="常见数据结构之 栈"></a>常见数据结构之 栈</h4><p><em><strong>先进后出</strong></em>的模型</p><hr><h4 id="常见数据结构之-队列"><a href="#常见数据结构之-队列" class="headerlink" title="常见数据结构之 队列"></a>常见数据结构之 队列</h4><p><em><strong>先进先出</strong></em>的模型</p><hr><h4 id="常见数据结构之-数组"><a href="#常见数据结构之-数组" class="headerlink" title="常见数据结构之 数组"></a>常见数据结构之 数组</h4><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704203333612-1691132000288160.png" alt="image-20230704203333612"></p><hr><h4 id="常见数据结构之-链表"><a href="#常见数据结构之-链表" class="headerlink" title="常见数据结构之 链表"></a>常见数据结构之 链表</h4><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704203940401-1691132000288161.png" alt="image-20230704203940401"></p><hr><h3 id="List集合的子类特点"><a href="#List集合的子类特点" class="headerlink" title="List集合的子类特点"></a>List集合的子类特点</h3><p>List集合常用子类：ArrayList，LinkedList</p><ul><li>ArrayList：底层数据结构是数组，查询快，增删慢</li><li>LInkedList：底层数据结构是链表，查询慢，增删快</li></ul><h3 id="LinkedList集合的特有功能"><a href="#LinkedList集合的特有功能" class="headerlink" title="LinkedList集合的特有功能"></a>LinkedList集合的特有功能</h3><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704205624625-1691132000288162.png" alt="image-20230704205624625"></p><hr><h3 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h3><ul><li><strong>不包含重复元素</strong>的集合</li><li>没有带索引的方法，所以不能使用普通for循环遍历</li></ul><p>HashSet：<strong>对集合的迭代顺序不作任何保证</strong></p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704210520430-1691132000288163.png" alt="image-20230704210520430"></p><hr><h4 id="哈希值"><a href="#哈希值" class="headerlink" title="哈希值"></a>哈希值</h4><p>哈希值：是JDK根据对象的<strong>地址</strong>或者<strong>字符串</strong>或者<strong>数字</strong>算出来的int类型的<strong>数值</strong></p><p>Object类中的一个方法可以获取<strong>对象的哈希值</strong></p><ul><li>public int hashCode()：返回对象的哈希码值</li></ul><p>特点：</p><ul><li><p>同一个对象多次调用hashCode()方法返回的哈希值是相同的</p></li><li><p>默认情况下，不同对象的哈希值是不相同的</p></li></ul><p>通过方法重写，可以实现不同对象的哈希值是相同的</p><p>字符串重写了hashCode 相同</p><hr><h3 id="HashSet集合"><a href="#HashSet集合" class="headerlink" title="HashSet集合"></a>HashSet集合</h3><p>HashSet集合特点</p><ul><li>底层数据结构是哈希表</li><li>对集合的迭代顺序不作任何保证，也就是说不保证存储和取出的元素顺序一致</li><li>没有带索引的方法，所以不能使用普通的for循环遍历</li></ul><hr><p><strong>HashSet集合保证元素唯一性的分析</strong></p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704212850545-1691132000288164.png" alt="image-20230704212850545"></p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704212949246-1691132000288165.png" alt="image-20230704212949246"></p><p> <em><strong>HashSet集合存储元素</strong></em></p><ul><li>要保证元素唯一性，需要重写<strong>hashCode()<strong>和</strong>equals()</strong></li></ul><hr><h3 id="常见数据类型之-哈希表"><a href="#常见数据类型之-哈希表" class="headerlink" title="常见数据类型之 哈希表"></a>常见数据类型之 哈希表</h3><p>哈希表</p><ul><li>JDK8之前，底层采用<em><strong>数组+链表</strong></em>实现，可以说是一个元素为链表的数组</li><li>JDK8以后，在长度比较长的时候，底层实现了优化</li></ul><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704213937954-1691132000289166.png" alt="image-20230704213937954"></p><p>哈希表保证了唯一性    hashCode计算哈希值 哈希表默认16位，取余16然后得到哈希值  然后存入哈希表  保证唯一性过程  先比较哈希值是否相同  如果相同再比较内容是否相同  如果都相同则不存入哈希表</p><hr><p>利用HashSet存储学生对象 并保证唯一性   需要重写两个方法  </p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704214845058-1691132000289167.png" alt="image-20230704214845058"></p><hr><h3 id="LinkedHashSet集合"><a href="#LinkedHashSet集合" class="headerlink" title="LinkedHashSet集合"></a>LinkedHashSet集合</h3><p>哈希表和链表实现的Set接口</p><p>概述：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704215248939-1691132000289168.png" alt="image-20230704215248939"></p><p>LinkedHashSet集合特点</p><ul><li>哈希表和链表实现的Set接口，具有可预测的迭代次序</li><li>由链表保持元素有序，也就是说元素的存储和取出顺序是一致的</li><li>由哈希表保证元素唯一，也就是说没有没有重复的元素</li></ul><hr><h3 id="TreeSet集合"><a href="#TreeSet集合" class="headerlink" title="TreeSet集合"></a>TreeSet集合</h3><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704220024617-1691132000289170.png" alt="image-20230704220024617"></p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704220005886-1691132000289169.png" alt="image-20230704220005886"></p><p>TreeSet集合特点</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704220331998-1691132000289171.png" alt="image-20230704220331998"></p><p>范例：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230704220525067-1691132000289172.png" alt="image-20230704220525067"></p><p><strong>继承Set所以没有重复元素</strong><strong>自然排序</strong></p><hr><h3 id="自然排序Comparable的使用"><a href="#自然排序Comparable的使用" class="headerlink" title="自然排序Comparable的使用"></a>自然排序Comparable的使用</h3><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230705080453702-1691132000289173.png" alt="image-20230705080453702"></p><ul><li>存储学生对象并遍历，创建TreeSet集合使用<strong>无参构造方法</strong></li><li>要求：按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序</li></ul><p>结论</p><ul><li>用TreeSet集合存储自定义对象，无参构造方法使用的是<strong>自然排序</strong>对元素进行排序的</li><li>自然排序，就是<strong>让元素所属的类实现Comparable接口</strong>，重写CompareTo(T o)方法</li><li>重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写</li></ul><hr><h3 id="比较器排序Comparator的使用"><a href="#比较器排序Comparator的使用" class="headerlink" title="比较器排序Comparator的使用"></a>比较器排序Comparator的使用</h3><ul><li>存储学生对象并遍历，创建TreeSet集合使用<strong>带参构造方法</strong></li><li>要求：按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序</li></ul><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230705084146605-1691132000289174.png" alt="image-20230705084146605"></p><p>结论：</p><ul><li>用TreeSet集合存储自定义对象，带参构造方法使用的时<em><strong>比较器排序</strong></em>对元素进行排序的</li><li>比较器排序，就是<strong>让集合构造方法接收comparator的实现类对象</strong>，重写compare(T o 1，T o 2)方法</li><li>重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写</li></ul><hr><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230705095209361-1691132000289175.png" alt="image-20230705095209361"></p><p>本质是<strong>参数化类型</strong></p><p>参数化类型就是：<strong>将类型由原来的具体的类型参数化，然后在使用/调用时传入具体的类型</strong></p><p>可以在类、方法、和接口中，分别成为泛型类、泛型方法、泛型接口</p><p>泛型定义格式：</p><ul><li>&lt;类型&gt;：指定一种类型的格式。这里的类型可以看成是形参</li><li>&lt;类型1，类型2…&gt;：指定多种类型的格式，多种类型之间用逗号隔开。这里的类型可以看成是形参</li><li>将来具体调用时候给定的类型可以看成是实参，并且实参的类型只能是引用数据类型</li></ul><p><strong>泛型的好处：</strong></p><ul><li>把运行使其的问题提前到了编译期间</li><li>避免了强制类型转换</li></ul><hr><h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230705100930218-1691132000289176.png" alt="image-20230705100930218"></p><p>定义和使用</p><p>定义</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230705101254562-1691132000289177.png" alt="image-20230705101254562"></p><p>使用</p><p>Generic &lt;String&gt;  gs1 = new Generic &lt;String&gt; ()  { }</p><p>gs1.setT()这时候参数就是String类型的</p><hr><h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230705105123832-1691132000289178.png" alt="image-20230705105123832"></p><hr><h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><p>泛型接口的定义格式：</p><ul><li>格式：修饰符 interface 接口名 &lt;类型&gt; { }</li></ul><p>泛型接口需要由泛型类来实现</p><hr><h4 id="类型通配符"><a href="#类型通配符" class="headerlink" title="类型通配符"></a>类型通配符</h4><p>为了表示各种泛型List的父类，可以使用类型通配符</p><ul><li>类型通配符：&lt;?&gt;</li><li>List&lt;?&gt;：表示元素类型未知的List，它的元素可以匹配<strong>任何的类型</strong></li><li>这种带通配符的List仅表示它是各种泛型List的父类，并不能把元素添加到其中</li></ul><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230705111231614-1691132000289179.png" alt="image-20230705111231614"></p><hr><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>可变参数又称参数个数可变，用作方法的形参出现，那么方法参数个数就是可变的了</p><ul><li>格式：修饰符 返回值类型 方法名(数据类型… 变量名) {  }</li><li>范例：public static int sum (int… a)  {  }</li></ul><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230705112431373-1691132000289180.png" alt="image-20230705112431373"></p><p>a 其实是一个数组 </p><p><strong>注意事项</strong></p><ul><li>这里的变量其实是一个数组</li><li>如果一个方法有多个参数，包含可变参数，<strong>可变参数要放在最后</strong></li></ul><hr><h4 id="可变参数的使用"><a href="#可变参数的使用" class="headerlink" title="可变参数的使用"></a>可变参数的使用</h4><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230705114241684-1691132000289182.png" alt="image-20230705114241684"></p><hr><h3 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h3><p>Map集合概述</p><ul><li>Interface Map&lt;K,V&gt;     K：键的类型；V：值得类型</li><li>将键映射到值得对象；不能包含重复得键；每个可以映射到最多一个值</li><li>举例：学生的学号和姓名</li></ul><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230705114542984-1691132000289183.png" alt="image-20230705114542984"></p><p>学号作为键唯一   姓名作为值被学号映射</p><p><strong>创建Map集合的对象</strong></p><ul><li>多态的方式</li><li>具体的实现类HashMap</li></ul><p>put方法用来添加数据  如果键重复则覆盖上一个键的值  也可做修改操作</p><hr><p>Map集合的基本功能</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230705140851166-1691132000289181.png" alt="image-20230705140851166"></p><hr><h4 id="Map集合的获取功能"><a href="#Map集合的获取功能" class="headerlink" title="Map集合的获取功能"></a>Map集合的获取功能</h4><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230705145555314-1691132000289184.png" alt="image-20230705145555314"></p><p>范例：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230705150042097-1691132000289185.png" alt="image-20230705150042097"></p><hr><h4 id="Map集合的遍历"><a href="#Map集合的遍历" class="headerlink" title="Map集合的遍历"></a>Map集合的遍历</h4><p>方式一：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230705150248102-1691132000289189.png" alt="image-20230705150248102"></p><p>范例：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230705150753420-1691132000289187.png" alt="image-20230705150753420"></p><p>方式二：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230705151459940-1691132000289186.png" alt="image-20230705151459940"></p><p> 范例：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230705151936943-1691132000289188.png" alt="image-20230705151936943"></p><hr><h5 id="HashMap存储值为Student遍历练习案例"><a href="#HashMap存储值为Student遍历练习案例" class="headerlink" title="HashMap存储值为Student遍历练习案例"></a>HashMap存储值为Student遍历练习案例</h5><p>范例：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230705153157775-1691132000289190.png" alt="image-20230705153157775"></p><hr><h5 id="HashMap存储键为Student遍历练习案例"><a href="#HashMap存储键为Student遍历练习案例" class="headerlink" title="HashMap存储键为Student遍历练习案例"></a>HashMap存储键为Student遍历练习案例</h5><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230705153509314-1691132000289191.png" alt="image-20230705153509314"></p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230705153539495-1691132000290192.png" alt="image-20230705153539495"></p><p>重写这两个方法自动生成即可</p><p>范例：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230705154032127-1691132000290193.png" alt="image-20230705154032127"></p><p>最后需要在Student类中重写equals和hashcode方法来确保数据唯一性  </p><p>//应该是因为中文字符串哈希值相同</p><hr><h5 id="ArrayList集合存储HashMap元素并遍历"><a href="#ArrayList集合存储HashMap元素并遍历" class="headerlink" title="ArrayList集合存储HashMap元素并遍历"></a>ArrayList集合存储HashMap元素并遍历</h5><p> 集合嵌套案例</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230705162155531-1691132000290194.png" alt="image-20230705162155531"></p><p>范例：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230705162104341-1691132000290195.png" alt="image-20230705162104341"></p><hr><h5 id="HashMap集合存储ArrayList元素并遍历"><a href="#HashMap集合存储ArrayList元素并遍历" class="headerlink" title="HashMap集合存储ArrayList元素并遍历"></a>HashMap集合存储ArrayList元素并遍历</h5><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230705165606140-1691132000290196.png" alt="image-20230705165606140"></p><p>范例：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230705165638614-1691132000290197.png" alt="image-20230705165638614"></p><hr><h5 id="统计字符串中每个字符出现的次数"><a href="#统计字符串中每个字符出现的次数" class="headerlink" title="统计字符串中每个字符出现的次数"></a>统计字符串中每个字符出现的次数</h5><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230705170301280-1691132000290198.png" alt="image-20230705170301280"></p><p>范例：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230705171450948-1691132000290199.png" alt="image-20230705171450948"></p><p>String s = sb.toStrint();</p><p>System.out.println(“s”);</p><p>可以用TreeMap改进，从而达到按照键自然排序</p><hr><h3 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h3><ul><li>针对集合操作的工具类</li></ul><p>Collection是一个接口，Collections是一个具体的类。</p><p>此类仅用静态方法组成，它包含对集合进行操作的算法 用类名直接直接调用方法即可</p><p><strong>Collections类的常用方法</strong></p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230705174128603-1691132000290200.png" alt="image-20230705174128603"></p><p>范例：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230705174924293-1691132000290201.png" alt="image-20230705174924293"></p><hr><h4 id="ArrayList存储学生对象并排序"><a href="#ArrayList存储学生对象并排序" class="headerlink" title="ArrayList存储学生对象并排序"></a>ArrayList存储学生对象并排序</h4><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230705191657508-1691132000290202.png" alt="image-20230705191657508"></p><hr><h4 id="模拟斗地主"><a href="#模拟斗地主" class="headerlink" title="模拟斗地主"></a>模拟斗地主</h4><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230705192235880-1691132000290204.png" alt="image-20230705192235880"></p><h4 id="模拟斗地主升级版"><a href="#模拟斗地主升级版" class="headerlink" title="模拟斗地主升级版"></a>模拟斗地主升级版</h4><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230705202059953-1691132000290203.png" alt="image-20230705202059953"></p><hr><h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><h3 id="File"><a href="#File" class="headerlink" title="File"></a>File</h3><p>File：它是啥文件和目录路径名的抽象表示</p><ul><li><p>文件和目录是可以通过File封装成对象的</p></li><li><p>对于File而言，其封装的并不是一个真正存在的文件，仅仅是一个路径名而已。它可以是存在的，也可以是不存在的。</p><p>将来时要通过具体的操作把这个路径的内容转换为具体存在的</p></li></ul><p><strong>构造方法：</strong></p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230705211512967-1691132000290205.png" alt="image-20230705211512967"></p><p> 范例：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230705211904972-1691132000290208.png" alt="image-20230705211904972"></p><p>三个输出相同</p><hr><h4 id="File类创建功能"><a href="#File类创建功能" class="headerlink" title="File类创建功能"></a>File类创建功能</h4><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230705212113472-1691132000290206.png" alt="image-20230705212113472"></p><p>范例：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230705213127181-1691132000290207.png" alt="image-20230705213127181"></p><p>同一个文件夹下创建同名不能成功，不能看名字来判断是否是文件，得看具体方法，如果方法用错了文件夹也可以 是文件的名称</p><hr><h4 id="File类判断和获取功能"><a href="#File类判断和获取功能" class="headerlink" title="File类判断和获取功能"></a>File类判断和获取功能</h4><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230705213707768-1691132000290209.png" alt="image-20230705213707768"></p><p>范例：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230705214438415-1691132000291214.png" alt="image-20230705214438415"></p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230705214456491-1691132000290210.png" alt="image-20230705214456491"></p><hr><h4 id="FIle类的删除功能"><a href="#FIle类的删除功能" class="headerlink" title="FIle类的删除功能"></a>FIle类的删除功能</h4><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230705214556730-1691132000291211.png" alt="image-20230705214556730"></p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230706073324179-1691132000291212.png" alt="image-20230706073324179"></p><p>空目录才能直接删除</p><p>创建文件的时候，找不到目录回报错</p><p>删除目录时候的注意事项：</p><ul><li>如果一个<strong>目录中有内容</strong>(目录，文件)，<strong>不能直接删除</strong>。应该先删除目录中的内容，最后才能删除目录</li></ul><hr><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>编程角度看，递归指的是方法定义中调用方法本身的现象</p><p>递归需要出口否则就回StackOverflowError：堆栈溢出，递归太深</p><p>把一个负责的问题层层转化为一个<strong>与原问题相似的规模较小</strong>的问题来求解</p><p>递归策略只需<strong>少量的程序</strong>就课描述出解题过程所需要的多次重复计算</p><p>递归解决问题要找到两个内容：</p><ul><li>递归出口：否则会出现内存溢出</li><li>递归规则：与原问题相似的规模较小的问题</li></ul><hr><h4 id="遍历目录"><a href="#遍历目录" class="headerlink" title="遍历目录"></a>遍历目录</h4><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230706092941538-1691132000291213.png" alt="image-20230706092941538"></p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230706095137233-1691132000291215.png" alt="image-20230706095137233"></p><hr><h3 id="IO流描述"><a href="#IO流描述" class="headerlink" title="IO流描述"></a>IO流描述</h3><ul><li><p>IO：输入/输出(input/output)</p></li><li><p>流：是一种抽象概念，是对数据传输的总称。也就是说数据在设备间的传输称为流，流的本质是数据传输</p></li><li><p>IO流就是用来处理设备间数据传输问题的</p><p>​常见的应用：文件复制；文件上传；文件下载</p></li></ul><p>IO流分类：</p><ul><li><p>按照数据的流向</p><p>输入流：读数据</p><p>输出流：写数据</p></li><li><p>按照数据类型来分</p><p>字节流</p><p>​字节输入流；字节输出流</p><p>字符流</p><p>​字符输入流；字符输出流</p></li></ul><p>一般来说，我们说IO流的分类是按照<strong>数据类型</strong>来分的</p><p>那么这两种流都在什么情况下使用呢？</p><ul><li>如果数据通过Window自带的记事本软件打开，我们能读懂里面的内容，就使用字符流，否则使用字节流。如果你不知道该使用哪种类型的流，就使用字节流。</li></ul><hr><h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><h3 id="字节流写数据"><a href="#字节流写数据" class="headerlink" title="字节流写数据"></a>字节流写数据</h3><p>跟IO相关基本都在Java.io包下需要导包</p><p>字节流抽象基类</p><ul><li><p>InputStream 类    这个抽象类是表示输入字节流的所有类的超类</p></li><li><p>OutputStream类  这个抽象类是表示字节输出流的所有类的超类</p></li><li><p>子类名特点：子类名称都是以其父类名作为子类名的后缀</p></li></ul><h4 id="FileOutputStream输出流"><a href="#FileOutputStream输出流" class="headerlink" title="FileOutputStream输出流"></a>FileOutputStream输出流</h4><p>FileOutputStream：文件输出流用于将数据写入File</p><ul><li>FIleOutputStream(String name)：创建文件输出流以指定的名称写入文件</li></ul><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230706104219980-1691132000291216.png" alt="image-20230706104219980"></p><p>做了三件事情:</p><ol><li>调用系统功能创建了文件</li><li>创建了字节输出流对象</li><li>让字节输出流对象指向创建好的文件</li></ol><p>使用字节输出流写数据的步骤：</p><ul><li>创建字节输出流对象（调用系统功能创建了文件，创建字节输出流对象，让字节输出流对象指向文件）</li><li>调用字节输出流对象的写数据方法   write  97代表a</li><li>释放资源（关闭此文件输出流并释放与此流相关联的任何系统资源）</li></ul><hr><h4 id="字节流写数据的三种方式"><a href="#字节流写数据的三种方式" class="headerlink" title="字节流写数据的三种方式"></a>字节流写数据的三种方式</h4><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230706110330100-1691132000291217.png" alt="image-20230706110330100"></p><p>范例：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230706112412720-1691132000291220.png" alt="image-20230706112412720"></p><hr><h4 id="字节流写数据的两个问题"><a href="#字节流写数据的两个问题" class="headerlink" title="字节流写数据的两个问题"></a>字节流写数据的两个问题</h4><p>字节流写数据如何实现换行？</p><ul><li><p>写完数据后，加换行符</p><p>windows：\r\n</p><p>linux：\n</p><p>mac：\r</p></li></ul><p>字节流写数据如何实现追加写入？</p><ul><li>publicFileOutputStream（String name，boolean append）</li><li>创建文件输出流以指定的名称写入文件。</li></ul><hr><h4 id="字节流写数据加异常处理"><a href="#字节流写数据加异常处理" class="headerlink" title="字节流写数据加异常处理"></a>字节流写数据加异常处理</h4><p>finally：在异常处理时提供finally块来执行所有清楚操作。比如说IO流中的释放资源</p><p>特点：被finally控制的语句一定会执行，除非JVM退出</p><p>格式用法：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230706142013150-1691132000291218.png" alt="image-20230706142013150"></p><p>健壮的程序 必要的判断需要写</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230706144822994-1691132000291221.png" alt="image-20230706144822994"></p><hr><h3 id="字节流读数据"><a href="#字节流读数据" class="headerlink" title="字节流读数据"></a>字节流读数据</h3><h4 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h4><p>File Input Stream：从文件系统中的文件获取输入字节</p><ul><li>FileInputStream（String name）：通过打开与实际文件的连接来创建一个FileInputStream，该文件由文件系统中的路径名 name命名</li></ul><p>使用字节输入流读数据的步骤</p><ol><li>创建字节输入流对象</li><li>调用字节输入流对象的读数据方法</li><li>释放资源</li></ol><p> 字节流读数据的标准代码（一次读一个字节）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> by<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>by <span class="token operator">=</span> finput<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> by<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><hr><h4 id="复制文本文件"><a href="#复制文本文件" class="headerlink" title="复制文本文件"></a>复制文本文件</h4><p>一次读一个字节复制操作</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230706155939189-1691132000291219.png" alt="image-20230706155939189"></p><hr><h4 id="字节流读数据-字节数组"><a href="#字节流读数据-字节数组" class="headerlink" title="字节流读数据 字节数组"></a>字节流读数据 字节数组</h4><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230706170851543-1691132000291222.png" alt="image-20230706170851543"></p><hr><h4 id="复制图片"><a href="#复制图片" class="headerlink" title="复制图片"></a>复制图片</h4><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230706172346753-1691132000291225.png" alt="image-20230706172346753"></p><hr><h3 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h3><ul><li>BufferOutputStream：该类实现缓冲输出流。通过设置这样的输出流，应用程序可以向底层输出流写入字节，而不必为写入的每个字节导致底层系统的调用</li><li>BufferedInputStream：创建BuferedInputStream将创建一个内部缓冲区数组。当从流中读取或跳过字节时，内部缓冲区将根据需要从所包含的输入流中重新填充，一次很多字节</li></ul><p>构造方法：</p><ul><li>字节缓冲输出流：BUfferedOutputStream（Output Stream out）</li><li>字节缓冲输入流：BUfferedInputStream（InputStream in）</li></ul><p>为什么构造方法需要的时字节流，而不是具体的文件或者路径呢？</p><ul><li>字节缓冲流<strong>仅仅提供缓冲区</strong>，而整整的读写数据还得依靠基本的字节流对象进行操作</li></ul><hr><p>范例：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230706200009673-1691132000291224.png" alt="image-20230706200009673"></p><p>复制视频四种案例  字节缓冲流，一次读写一个字节数组 最快</p><hr><h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><p>一个汉字存储：</p><p>​如果是GBK编码，占用2个字节</p><p>​如果是UTF-8编码，占用3个字节 </p><p>由于字节流操作中文不是特别的方便，所以Java就提供了字符流</p><ul><li><strong>字符流 = 字节流 + 编码表</strong></li></ul><p>用字节流复制文本文件是，文本文件也会有中文，但是没有问题，原因是最终底层操作会自动进行字节拼接成中文，如何识别是中文的呢？</p><ul><li><strong>汉字在存储的时候，无论选择哪种编码存储，第一个字节都是负数</strong></li></ul><hr><h3 id="编码表"><a href="#编码表" class="headerlink" title="编码表"></a>编码表</h3><p>基础知识：</p><ul><li><p>计算机储存信息都是<strong>二进制</strong>数表示；我们在屏幕上看到的英文、汉字字符是二进制数转换之后的结果</p></li><li><p>按照某种规则，将字符存储导计算机中，称为<strong>编码</strong>。反之，将存储在计算机中二进制数按照某种规则解析显示出来，称为<strong>解码</strong>。这里强调一下：按照A的编码存储，必须按照A编码解析，这样才能显示正确符号。否则就会导致乱码现象</p><p>​字符编码：就是一套自然语言的字符与二进制数之间的对应规则（A,65）</p></li></ul><p>字符集：</p><ul><li><p>是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等</p></li><li><p>计算机要准确的存储和识别各种字符集符号，就需要进行字符编码，一套字符集必然至少有一套字符编码</p><p>常见字符集有ASCII字符集、GBXXX字符集、Unicode字符集等</p></li></ul><hr><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230710110629762-1691132000291223.png" alt="image-20230710110629762"></p><hr><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230710110908641-1691132000291226.png" alt="image-20230710110908641"></p><hr><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230710111306303-1691132000291227.png" alt="image-20230710111306303"></p><hr><h3 id="字符串中编码解码问题"><a href="#字符串中编码解码问题" class="headerlink" title="字符串中编码解码问题"></a>字符串中编码解码问题</h3><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230710112537924-1691132000291228.png" alt="image-20230710112537924"></p><hr><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230710112550624-1691132000291230.png" alt="image-20230710112550624"></p><p>使用何种方式编码，就要使用何种方式解码，否则会乱码</p><hr><h3 id="字符流中的编码解码问题"><a href="#字符流中的编码解码问题" class="headerlink" title="字符流中的编码解码问题"></a>字符流中的编码解码问题</h3><p>字符流抽象基类</p><ul><li>Reader：字符输入流的抽象类</li><li>Writer：字符输出流的抽象类</li></ul><p>字符流中和编码解码问题相关的两个类</p><ul><li>InputStreamReader</li><li>OutputStreamWriter</li></ul><p>范例：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230710135322204-1691132000291229.png" alt="image-20230710135322204"></p><hr><h3 id="字符流写数据的5种方法"><a href="#字符流写数据的5种方法" class="headerlink" title="字符流写数据的5种方法"></a>字符流写数据的5种方法</h3><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230710135926209-1691132000291233.png" alt="image-20230710135926209"></p><hr><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230710143626913-1691132000291232.png" alt="image-20230710143626913"></p><p>了解flush（）和close（）方法的区别</p><hr><h3 id="字符流读数据的2种方式"><a href="#字符流读数据的2种方式" class="headerlink" title="字符流读数据的2种方式"></a>字符流读数据的2种方式</h3><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230710143919033-1691132000291234.png" alt="image-20230710143919033"></p><p>遍历读取  </p><p>先定义</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230710154354530-1691132000291231.png" alt="image-20230710154354530"></p><p>一次读一个字符数据</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230710154430669-1691132000291235.png" alt="image-20230710154430669"></p><p>一次读一个字符数组数据</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230710154449060-1691132000291239.png" alt="image-20230710154449060"></p><hr><p>两种简单的方法</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230710162551405-1691132000291237.png" alt="image-20230710162551405"></p><p>遍历读取写入与上相同</p><hr><h3 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h3><p>字符缓冲流：</p><ul><li>BufferedWriter：将文本写入字符输出流，缓冲字符，以提供单个字符，数组和字符串的高效写入，可以指定缓冲区大小，或者可以接受默认大小。默认值足够大，可用于大多数用途</li><li>BufferedReader：从字符输入流读取文本，缓冲字符，以提供字符，数组和行的高效读取，可以指定缓冲区大小，或者可以使用默认大小。默认值足够大，可用于大多数用途</li></ul><hr><p>构造方法：</p><ul><li>BufferedWriter(Writer out)    </li><li>BufferedReader(Reader in)</li></ul><p>参数用FileReader或者OutStreamWriter都可以</p><hr><p>字符缓冲流复制文件  这是其中一种方法用的字符数组</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">BufferedReader</span> br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span><span class="token string">"file.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token class-name">BufferedWriter</span> bw <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileWriter</span><span class="token punctuation">(</span><span class="token string">"filecopy2.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//</span>     <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token keyword">int</span> len<span class="token punctuation">;</span>     <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>len <span class="token operator">=</span> br<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         bw<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>ch<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     br<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     bw<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="字符缓冲流特有功能"><a href="#字符缓冲流特有功能" class="headerlink" title="字符缓冲流特有功能"></a>字符缓冲流特有功能</h3><p>BufferedWriter:</p><ul><li>void newLine(): 写一行行分隔符，行分隔符字符串由系统属性定义</li></ul><p>BufferedReader:</p><ul><li>public String readLine(): 读一行文字。结果包含行的内容的字符串，<strong>不包括任何行终止字符</strong>，如果流的结尾已经到达，则为null</li></ul><p>改进循环读取</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230710185012268-1691132000291238.png" alt="image-20230710185012268"></p><p>改进复制文件  <strong>最常用</strong> 优先掌握</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">BufferedReader</span> br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span><span class="token string">"file.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token class-name">BufferedWriter</span> bw <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileWriter</span><span class="token punctuation">(</span><span class="token string">"filecopy3.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//遍历</span>      <span class="token class-name">String</span> st<span class="token punctuation">;</span>      <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>st <span class="token operator">=</span> br<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          bw<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span>          bw<span class="token punctuation">.</span><span class="token function">newLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          bw<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      br<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      bw<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="IO流小结"><a href="#IO流小结" class="headerlink" title="IO流小结"></a>IO流小结</h2><p><strong>字节流小结</strong></p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230710190929738-1691132000291236.png" alt="image-20230710190929738"></p><ul><li><strong>字节流可以复制任意文件数据，有4种方式一般采用字节缓冲流一次读写一个字节数组的方式</strong></li></ul><p><strong>字符流小结</strong></p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230710191331115-1691132000291240.png" alt="image-20230710191331115"></p><ul><li><strong>字符流只能复制文本数据，有5种方式，一般采用字符缓冲流的特有功能</strong></li></ul><hr><h3 id="集合到文件案例"><a href="#集合到文件案例" class="headerlink" title="集合到文件案例"></a>集合到文件案例</h3><hr><h3 id="文件到集合案例"><a href="#文件到集合案例" class="headerlink" title="文件到集合案例"></a>文件到集合案例</h3><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230710201809617-1691132000292242.png" alt="image-20230710201809617"></p><hr><hr><h3 id="案例：点名器"><a href="#案例：点名器" class="headerlink" title="案例：点名器"></a>案例：点名器</h3><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230710202215866-1691132000291241.png" alt="image-20230710202215866"></p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230710203642644-1691132000292243.png" alt="image-20230710203642644"></p><hr><h3 id="集合到文件改进版"><a href="#集合到文件改进版" class="headerlink" title="集合到文件改进版"></a>集合到文件改进版</h3><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230710212232696-1691132000292244.png" alt="image-20230710212232696"></p><hr><h3 id="文件到集合改进版"><a href="#文件到集合改进版" class="headerlink" title="文件到集合改进版"></a>文件到集合改进版</h3><p>split分割 按照指定字符分割字符串  赋给字符串数组</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230710213218323-1691132000292246.png" alt="image-20230710213218323"></p><hr><p>集合到文件 数据排序进阶版</p><hr><h3 id="案例：复制单级文件夹"><a href="#案例：复制单级文件夹" class="headerlink" title="案例：复制单级文件夹"></a><strong>案例：复制单级文件夹</strong></h3><p>需求：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230711075657869-1691132000292247.png" alt="image-20230711075657869"></p><hr><p>代码示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CopyDir</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>        <span class="token class-name">File</span> fl1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"C:\\Users\\李嘉欣\\Desktop\\CopyDemo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> name <span class="token operator">=</span> fl1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">File</span> fl2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>fl2<span class="token punctuation">.</span><span class="token function">exists</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            fl2<span class="token punctuation">.</span><span class="token function">mkdir</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token class-name">File</span><span class="token punctuation">[</span><span class="token punctuation">]</span> files <span class="token operator">=</span> fl1<span class="token punctuation">.</span><span class="token function">listFiles</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">File</span> flt<span class="token operator">:</span>files<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token class-name">String</span> name1 <span class="token operator">=</span> flt<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">File</span> fl4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>fl2<span class="token punctuation">,</span> name1<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">methos1</span><span class="token punctuation">(</span>flt<span class="token punctuation">,</span>fl4<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">methos1</span><span class="token punctuation">(</span><span class="token class-name">File</span> flt<span class="token punctuation">,</span> <span class="token class-name">File</span> fl4<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>        <span class="token class-name">BufferedInputStream</span> bis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>flt<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">BufferedOutputStream</span> bos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedOutputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span>fl4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> len<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>len <span class="token operator">=</span> bis<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            bos<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        bis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bos<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="复制多级文件夹"><a href="#复制多级文件夹" class="headerlink" title="复制多级文件夹"></a><strong>复制多级文件夹</strong></h3><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230711082243140-1691132000292245.png" alt="image-20230711082243140"></p><hr><p>代码示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CopyFolederDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> main <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">{</span>        <span class="token class-name">File</span> srcFile <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"C:\\Users\\李嘉欣\\Desktop\\CopyDemo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">File</span> destFile <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//</span>        <span class="token function">copyFolder</span><span class="token punctuation">(</span>srcFile<span class="token punctuation">,</span>destFile<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">copyFolder</span><span class="token punctuation">(</span><span class="token class-name">File</span> srcFile<span class="token punctuation">,</span> <span class="token class-name">File</span> destFile<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>srcFile<span class="token punctuation">.</span><span class="token function">isDirectory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token class-name">String</span> srcFileName <span class="token operator">=</span> srcFile<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">File</span> newFloder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>destFile<span class="token punctuation">,</span>srcFileName<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>newFloder<span class="token punctuation">.</span><span class="token function">exists</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                newFloder<span class="token punctuation">.</span><span class="token function">mkdir</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token class-name">File</span><span class="token punctuation">[</span><span class="token punctuation">]</span> fileArray <span class="token operator">=</span> srcFile<span class="token punctuation">.</span><span class="token function">listFiles</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">File</span> file<span class="token operator">:</span>fileArray<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token function">copyFolder</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span>newFloder<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token class-name">File</span> newFile <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>destFile<span class="token punctuation">,</span>srcFile<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">copyFile</span><span class="token punctuation">(</span>srcFile<span class="token punctuation">,</span>newFile<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">copyFile</span><span class="token punctuation">(</span><span class="token class-name">File</span> srcFile<span class="token punctuation">,</span> <span class="token class-name">File</span> destFile<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>        <span class="token class-name">BufferedInputStream</span> bis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>srcFile<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">BufferedOutputStream</span> bos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedOutputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span>destFile<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bys <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> len<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>len <span class="token operator">=</span> bis<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>bys<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            bos<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>bys<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        bis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bos<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="复制文件的异常处理"><a href="#复制文件的异常处理" class="headerlink" title="复制文件的异常处理"></a>复制文件的异常处理</h2><p>标准处理流程：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230711104620690-1691132000292248.png" alt="image-20230711104620690"></p><hr><p>JDK7的改进方案： <strong>用的更多点</strong></p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230711104637624-1691132000292250.png" alt="image-20230711104637624"></p><hr><p>JDK9的改进方案  仍需抛出  </p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230711104713401-1691132000292249.png" alt="image-20230711104713401"></p><hr><h2 id="特殊操作流"><a href="#特殊操作流" class="headerlink" title="特殊操作流"></a>特殊操作流</h2><p>标准输入输出流</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230711105122890-1691132000292251.png" alt="image-20230711105122890"></p><hr><h3 id="标准输入流"><a href="#标准输入流" class="headerlink" title="标准输入流"></a>标准输入流</h3><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230711110928952-1691132000292252.png" alt="image-20230711110928952"></p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230711111139171-1691132000292253.png" alt="image-20230711111139171"></p><hr><h3 id="标准输出流"><a href="#标准输出流" class="headerlink" title="标准输出流"></a>标准输出流</h3><p> <img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230711112143237-1691132000292254.png" alt="image-20230711112143237"></p><hr><h3 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h3><p> 打印流分类：</p><ul><li>字节打印流：PrintStream</li><li>字符打印流：Printwriter</li></ul><p>打印流的特点：</p><ul><li>只负责输出数据，不负责读取数据</li><li>有自己的特有方法</li></ul><h3 id="字节打印流"><a href="#字节打印流" class="headerlink" title="字节打印流"></a>字节打印流</h3><ul><li><p>PrintStream(String fileName)：使用指定的文件名创建新的打印流</p></li><li><p>使用继承父类的方法写数据，查看的时候会转码；使用自己的特有方法写数据，查看的的数据原样输出</p></li></ul><hr><h3 id="字符打印流"><a href="#字符打印流" class="headerlink" title="字符打印流"></a>字符打印流</h3><p>创建字符打印流时，如果需要自动刷新流</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230711150834872-1691132000292255.png" alt="image-20230711150834872"></p><p>然后print println方法就会自动刷新</p><hr><h3 id="复制java文件打印流改版"><a href="#复制java文件打印流改版" class="headerlink" title="复制java文件打印流改版"></a>复制java文件打印流改版</h3><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230711151624916-1691132000292256.png" alt="image-20230711151624916"></p><hr><h3 id="对象序列化流"><a href="#对象序列化流" class="headerlink" title="对象序列化流"></a>对象序列化流</h3><p>对象序列化：就是将对象保存到磁盘中，或者在网络中传输对象</p><p>这种机制就是使用一个字节序列表示一个对象，该字节序列包含：对象的类型、对象的数据和对象中存储的属性等信息</p><p>字节序列写到文件之后，相当于文件中持久保存了一个对象信息</p><p>反之，该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化</p><p>要实现序列化和反序列化就要使用对象序列化流和对象反序列化流：</p><ul><li>对象序列化流：ObjectOutputStream</li><li>对象反序列化流：ObjectInputStream</li></ul><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230711153116820-1691132000292259.png" alt="image-20230711153116820"></p><p>使用序列化对象 对象需要<strong>实现Serializable接口</strong>  此接口只是一个<strong>标识</strong>接口  没有抽象方法 不需要重写方法</p><p>看到此接口  就要知道此类可以被序列化和反序列化</p><p>对象序列化流 示例：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230711160217006-1691132000292257.png" alt="image-20230711160217006"></p><p><em><strong>注意事项：</strong></em></p><ul><li>一个对象要想被序列化，该对象所属的类必须实现<strong>Serializable接口</strong></li><li><strong>Serializable</strong>是一个<strong>标记</strong>接口，实现该接口，不需要重写任何方法</li></ul><hr><h3 id="对象反序列化流"><a href="#对象反序列化流" class="headerlink" title="对象反序列化流"></a>对象反序列化流</h3><p>反序列化先前使用ObjectOutputStream编写的原始数据和对象  </p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230711162604512-1691132000292258.png" alt="image-20230711162604512"></p><p>反序列化流的使用</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230711162950959-1691132000292260.png" alt="image-20230711162950959"></p><hr><h3 id="序列化异常修改与不想被序列化"><a href="#序列化异常修改与不想被序列化" class="headerlink" title="序列化异常修改与不想被序列化"></a>序列化异常修改与不想被序列化</h3><p><strong>serialVersionUID&amp;transient</strong>   问题</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230711164158110-1691132000292261.png" alt="image-20230711164158110"></p><hr><h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h3><p>Properties作为Map集合的使用  Properties没有指定泛型</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230711165958221-1691132000292263.png" alt="image-20230711165958221"></p><hr><p>Properties作为集合的特有方法：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230711172113632-1691132000293264.png" alt="image-20230711172113632"></p><p>示例：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230711172103818-1691132000292262.png" alt="image-20230711172103818"></p><hr><h3 id="Properties和IO流结合的方法："><a href="#Properties和IO流结合的方法：" class="headerlink" title="Properties和IO流结合的方法："></a>Properties和IO流结合的方法：</h3><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230711172436809-1691132000293265.png" alt="image-20230711172436809"></p><p> 结合示例：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230711175922374-1691132000293266.png" alt="image-20230711175922374"></p><p>myLoad 文件中数据加载到集合</p><p>myStore集合中的数据保存到文件</p><hr><p>案例：游戏次数</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230711192758310-1691132000293267.png" alt="image-20230711192758310"></p><hr><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p>进程：是正在运行的程序</p><ul><li>是系统进行资源分配和调用的独立单位</li><li>每一个进程都有它自己的内存空间和系统资源</li></ul><p>线程：是进程中的单个顺序控制流，是一条执行路径</p><ul><li>单线程：一个进程如果只有一条执行路径，则称为单线程程序</li><li>多线程：一个进程如果有多条执行路径，则称为多线程程序</li></ul><p>举例：</p><ul><li>记事本程序 单线程  同时只能执行一个</li><li>扫雷程序  多线程  最少两个线程在同时执行   边扫雷  边计时</li></ul><hr><h3 id="多线程的的实现方式1-继承Thread类"><a href="#多线程的的实现方式1-继承Thread类" class="headerlink" title="多线程的的实现方式1  继承Thread类"></a>多线程的的实现方式1  继承Thread类</h3><p>方式1：<strong>继承Thread类</strong></p><ul><li>定义一个类MyThread继承Thread类</li><li>在MyThread类中重写run() 方法</li><li>创建MyThread类的对象</li><li>启动线程</li></ul><p>两个问题：</p><ul><li><p>为什么重写run() 方法？</p><p>​因为run() 是用来封装被线程执行的代码</p></li><li><p>run() 方法 和 start() 方法的区别？</p><p>​run() ：封装线程执行的代码，直接调用，相当于普通方法的调用</p><p>​start()：启动线程；然后由JVM调用此线程的run() 方法</p></li></ul><hr><h3 id="设置和获取线程名称"><a href="#设置和获取线程名称" class="headerlink" title="设置和获取线程名称"></a>设置和获取线程名称</h3><p>Thread类中设置和获取线程名称的方法</p><ul><li>void setName(String name)：将此线程的名称更改为等于参数name</li><li>String getName()：返回此线程的名称</li></ul><p>无参构造会给赋一个默认的线程名称 Thread-0 开始</p><p>使用setName更改   通过getName获取</p><p>带参构造方法也可以设置线程名称  </p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230712090422493-1691132000293268.png" alt="image-20230712090422493"></p><p>不过得在线程类中 设置无参和带参构造方法用来把参数传给Thread   继承Thread类  </p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230712090552892-1691132000293269.png" alt="image-20230712090552892"></p><p>Thread类中 静态的方法currentThread() 返回对当前正在执行的线程对象的引用</p><p>示例： 返回main线程的名称</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230712090742632-1691132000293271.png" alt="image-20230712090742632"></p><p>main方法线程名为main</p><p><strong>总结：</strong></p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230712091020131-1691132000293270.png" alt="image-20230712091020131"></p><hr><h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><p>线程有两种调度模型</p><ul><li><strong>分时调度模型</strong>：所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间片</li><li><strong>抢占式调度模型</strong>：优先让优先级高的线程使用CPU，如果线程的优先级相同，那么就会随机选择一个，优先级高的线程获取的CPU时间片相对多一些</li></ul><p>Java使用的是抢占式调度模型</p><p>加入计算机只有一个CPU，那么CPU在某一个时刻只能执行一条指令，线程只有得到CPU时间片，也就是使用权，才可以执行指令。所以说多线程程序的执行是有<em><strong>随机性</strong></em>，因为谁抢到了CPU使用权是不一定的</p><p>Thread类中设置和获取线程优先级的方法</p><ul><li>public final int **getPriority()**：返回此线程的优先级</li><li>public final void **setPriority(int newPriority)**：更改此线程的优先级</li></ul><p>​线程默认优先级是<strong>5</strong>；线程优先级的范围是：1-10</p><p>​线程优先级高仅仅表示线程获取的CPU时间片的几率高，但是要在次数比较多，或者多次运行的时候才能看到你想要的效果</p><hr><h3 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h3><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230712093830037-1691132000293273.png" alt="image-20230712093830037"></p><hr><h3 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h3><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230712100140471-1691132000293272.png" alt="image-20230712100140471"></p><hr><h3 id="多线程的实现方式2-实现Runnable接口"><a href="#多线程的实现方式2-实现Runnable接口" class="headerlink" title="多线程的实现方式2  实现Runnable接口"></a>多线程的实现方式2  实现Runnable接口</h3><p>方式2：实现Runnable接口</p><ul><li><p>定义一个类MyRuannbale实现Runnable接口</p></li><li><p>在MyRunnable类中重写run() 方法</p></li><li><p>创建MyRunnable类的对象</p></li><li><p>创建Thread类的对象，把MyRunnable对象作为构造方法的参数</p></li><li><p>启动线程</p></li></ul><p>多线程的实现方案有两种</p><ul><li>继承Thread类</li><li>实现Runnable接口</li></ul><p>相比继承Thread类，实现Runnable接口的好处</p><ul><li>避免了Java单继承的局限性</li><li>适合多个相同程序的代码去处理同一个资源的情况，把线程和程序的代码、数据有效分离，较好的体现了面向对象的设计思想</li></ul><hr><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>案例：卖票</p><hr><p>卖票出现了我呢提</p><ul><li>相同的票出现了多次</li><li>出现了负数的票</li></ul><p>问题原因：</p><ul><li>线程执行的随机性导致的</li></ul><hr><p>卖票案例数据安全问题的解决</p><p>为什么出现问题？（这也是我们判断多线程程序是否有数据安全问题的标准）</p><ul><li>是否是多线程环境</li><li>是否有共享数据</li><li>是否有多条语句操作共享数据</li></ul><p>三个问题都有肯定会出现数据安全问题</p><p>如何解决多线程安全问题呢？</p><ul><li>基本思想：让程序没有安全问题的环境</li></ul><p>怎么实现呢？</p><ul><li><p>把多条语句操作共享数据的代码锁起来，让任意时刻只能有一个线程执行即可</p></li><li><p>Java提供了同步代码块的方式来解决</p></li></ul><p><strong>同步代码块：</strong></p><p>锁多条语句操作共享数据，可以使用同步代码块实现</p><ul><li><p>格式：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">synchronized</span><span class="token punctuation">(</span>任意对象<span class="token punctuation">)</span><span class="token punctuation">{</span>多条语句操作共享数据的代码<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>synchronized(任意对象)：就相当于给代码加锁了，任意对象就可以看成是一把锁</p></li></ul><p>同步的好处和弊端</p><ul><li>好处：解决了多线程的数据安全问题</li><li>弊端：当线程很多时，因为每个线程都会去判断同步上的锁，这是很耗费资源的，无形中会降低程序的运行效率</li></ul><p>同步代码块解决卖票问题：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230712160542297-1691132000293274.png" alt="image-20230712160542297"></p><hr><p><strong>同步方法：</strong></p><p>同步方法：就是把synchronized关键字加到方法上</p><ul><li><p>格式：</p><p>修饰符<strong>synchronized</strong>f返回值类型 方法名(方法参数)  {   }</p></li></ul><p>同步方法的锁对象是什么呢？</p><ul><li><strong>this</strong></li></ul><p>同步静态方法的锁对象是什么呢？</p><ul><li><strong>类名.class</strong></li></ul><hr><h3 id="线程安全的类"><a href="#线程安全的类" class="headerlink" title="线程安全的类"></a>线程安全的类</h3><p><strong>StringBuffer</strong>    这个会用</p><ul><li>线程安全，可变的字符序列   </li><li>从JDK5开始，被StringBuilder替代。通常应该使用StringBuilder类，因为它支持所有相同的操作，单它更快，因为它不执行同步</li></ul><p><strong>Vector</strong>已被Collections里面的静态方法synchronizedList(List&lt;T&gt;  List)替代</p><ul><li>从Java2平台v1.2开始，该类改进了List接口，使其成为了Java Collections Farmwork的成员。与新的集合不同，Vector被同步。如果不需要线程安全的实现，建议使用ArrayList代替Vector</li></ul><p></p><p><strong>Hashtable</strong>    已被Collections里面的静态方法synchronizedMap(Map&lt;K,V&gt;  m)替代</p><ul><li><p>该类实现了一个哈希表，它将键映射到值。任何非null对象都可以用作键或者值</p></li><li><p>从Java 2平台v1.2开始，该类进行了改进，实现了Map接口，使其成为Java Collections Farmwork的成员。与新的集合实现不同。Hashtable被同步。如果不需要线程安全的实现，建议使用HashMap代替Hashtable</p></li></ul><p>还有Collections里面的静态方法synchronizedSet(Set&lt;T&gt;  s)</p><hr><h3 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h3><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230712191150865-1691132000293276.png" alt="image-20230712191150865"></p><p>Lock实现提供比使用synchronized方法和语句可以获得更广泛的锁定操作</p><p>Lock中提供了获得锁和释放锁的方法</p><ul><li><strong>void lock()：获得锁</strong></li><li><strong>void unlock()：释放锁</strong></li></ul><p>Lock是接口不能直接实例化，这里采用它的实现类ReentrantLock来实例化</p><p><strong>ReentrantLock</strong>的构造方法</p><ul><li><strong>ReentranLock()：创建一个ReentrantLock的实例</strong></li></ul><p>示例：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230712193708141-1691132000293277.png" alt="image-20230712193708141"></p><hr><h3 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h3><p> 生产者消费者模式是一个非常经典的多线程协作的模式，弄懂生产者消费者问题能够让让我们对多线程编程的理解更加深刻</p><p>所谓的生产者消费者问题，实际上主要是包含了两类线程：</p><ul><li>一类是生产者线程用于生产数据</li><li>一类是消费者线程用于消费数据</li></ul><p>为了解耦生产者和消费者的关系，通常会采用共享的数据区域，就像是一个仓库</p><ul><li>生产者生产数据之后直接放置在共享数据区中，并不需要关心消费者的行为</li></ul><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230712205122783-1691132000293275.png" alt="image-20230712205122783"></p><hr><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230712205140846-1691132000293278.png" alt="image-20230712205140846"></p><hr><h3 id="生产者消费者案例"><a href="#生产者消费者案例" class="headerlink" title="生产者消费者案例"></a>生产者消费者案例</h3><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230712205451480-1691132000293279.png" alt="image-20230712205451480"></p><p>等待wait()      唤醒notifyAll()  notify()</p><hr><h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><p>计算机网络：</p><ul><li>是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下、实现资源共享和信息传递的计算机系统</li></ul><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230713082355098-1691132000293280.png" alt="image-20230713082355098"></p><p>网络编程</p><ul><li>在 网络通信协议下， 实现网络互连的不同计算机上运行的程序之间可以进行数据交换</li></ul><h3 id="网络编程三要素"><a href="#网络编程三要素" class="headerlink" title="网络编程三要素"></a>网络编程三要素</h3><p><strong>IP地址</strong></p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230713083457550-1691132000293282.png" alt="image-20230713083457550"></p><p><strong>端口</strong></p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230713083512579-1691132000293283.png" alt="image-20230713083512579"></p><p><strong>协议</strong></p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230713083555111-1691132000293281.png" alt="image-20230713083555111"></p><hr><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a><strong>IP地址</strong></h3><p>IP地址：是网络中设备的唯一标识</p><p>IP地址分为两大类</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230713083725290-1691132000293284.png" alt="image-20230713083725290"></p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230713083738299-1691132000293285.png" alt="image-20230713083738299"></p><p>常用命令：</p><ul><li>ipconfig：查看本机IP地址</li><li>ping IP地址：检查网络是否连通</li></ul><p>特殊IP地址：</p><ul><li>127.0.0.1：回送地址，可以代表本机地址，一般用来测试</li></ul><hr><h3 id="InetAddress的使用"><a href="#InetAddress的使用" class="headerlink" title="InetAddress的使用"></a>InetAddress的使用</h3><p>为了方便我们对IP地址的获取和操作，Java提供了一个类InetAddress供我们使用</p><p>InetAddress：此类表示Internet协议 (IP) 地址</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230713085131103-1691132000293286.png" alt="image-20230713085131103"></p><p>示例：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230713100552524-1691132000293287.png" alt="image-20230713100552524"></p><hr><h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><p>端口：设备上应用程序的唯一标识</p><p>端口号：用两个字节表示的整数，它的取值范围是0<del>65535。其中，0</del>1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败</p><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>协议：计算机网络中，连接和通信的规则被称为网络通信协议</p><p><strong>UDP协议</strong></p><ul><li>用户数据报协议（User Datagram Protocol）</li><li>UDP是<strong>无连接</strong>通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确定接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。</li></ul><p>由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230713101426178-1691132000293290.png" alt="image-20230713101426178"></p><p><strong>TCP协议</strong></p><ul><li><p>传输控制协议（Transmission Control Procol）</p></li><li><p>TCP协议是<strong>面向连接</strong>的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间<strong>可靠无差错</strong>的数据传输。在TCP连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过  ”三次握手“</p></li><li><p>三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠</p><p>第一次握手，客户端向服务器端发出连接请求，等待服务器确认</p><p>第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求</p><p>第三次握手，客户端再次向服务器端发送确认信息，确认连接</p></li></ul><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230713102306039-1691132000293288.png" alt="image-20230713102306039"></p><ul><li>完成三次握手，连接建立后，客户端和服务器就可以进行数据传输了。由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛。例如上传文件、下载文件、浏览网页等</li></ul><hr><h3 id="UDP通信程序"><a href="#UDP通信程序" class="headerlink" title="UDP通信程序"></a>UDP通信程序</h3><p>UDP协议是一种不可靠的网络协议，它在通信的两端各建立一个Socket对象，但是这两个Socket只是发送，接受数据的对象</p><p>因此对于基于UDP协议的通信双方而言，没有所谓的客户端和服务器的概念 </p><p>Java提供了DatagramSocket类作为基于UDP协议的Socket</p><h4 id="UDP发送数据"><a href="#UDP发送数据" class="headerlink" title="UDP发送数据"></a>UDP发送数据</h4><p>发送数据的步骤</p><ol><li><p>创建发射端的Socket对象（DatagramSocket）</p><p>DatagramSocket()</p></li><li><p>创建数据，并把数据打包</p><p>DatagramPacket(byte[] buf,int length, Inetaddress address,int port)</p></li><li><p>调用DatagramSocket对象的方法发送数据</p><p>void send(DatagramPacket p)</p></li><li><p>关闭发送端 </p></li><li><p>void close()</p></li></ol><p>范例：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230713145005578-1691132000293289.png" alt="image-20230713145005578"></p><hr><h4 id="UDP接收数据"><a href="#UDP接收数据" class="headerlink" title="UDP接收数据"></a>UDP接收数据</h4><p>接收数据的步骤</p><ol><li><p>创建接收端的Socket对象（DatagramScoket）</p><p>​DatagramSocket(int port)</p></li><li><p>创建一个数据包，用于接收数据</p><p>​DatagramPacket(byte[] buf, int length)</p></li><li><p>调用DatagramSocket对象的方法接收数据</p><p>​void receive(DatagramPacket p)</p></li><li><p>解析数据包，并把数据在控制台显示</p><p>​byte[] getdata()</p><p>​int getLength()</p></li><li><p>关闭接收端</p><p>​void close()</p></li></ol><p>范例：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230713150524225-1691132000293292.png" alt="image-20230713150524225"></p><hr><h3 id="TCP通信程序"><a href="#TCP通信程序" class="headerlink" title="TCP通信程序"></a>TCP通信程序</h3><p>TCP通信原理</p><p>TCP通信协议是一种可靠的网络协议，它在通信的两端各建立一个Socket对象，从而在通信的两端形成网络虚拟链路，一旦建立了虚拟的网络链路，两端的程序就可以通过虚拟链路进行通信</p><p>Java对基于TCP协议的网络提供了良好的封装，使用Socket对象来代表两端的通信端口，并通过Socket<strong>产生IO流</strong>来进行网络通信</p><p>Java为客户端提供了Socket类，为服务器端提供了ServerSocket类</p><h4 id="TCP发送数据"><a href="#TCP发送数据" class="headerlink" title="TCP发送数据"></a>TCP发送数据</h4><p>发送数据的步骤</p><ol><li><p>创建客户端的Socket对象（Socket）</p><p>Socket    (String host,int port)</p></li><li><p>获取输出流，写数据<br>OutputStream    getOutputStream()</p></li><li><p>释放资源<br>void close( )</p></li></ol><p>范例：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230713201843534-1691132000293291.png" alt="image-20230713201843534"></p><hr><h4 id="TCP接收数据"><a href="#TCP接收数据" class="headerlink" title="TCP接收数据"></a>TCP接收数据</h4><p>接收数据的步骤</p><ol><li><p>创建服务器端的Socket对象（ServerSocket）</p><p>​ServerSocket(int port)</p></li><li><p>监听客户端连接，返回一个Socket对象</p><p>​Socket accept( )</p></li><li><p>获取输入流，读数据，并把数据显示再控制台</p><p>​InputStream getInputStream( )</p></li><li><p>释放资源<br>void close(  )</p></li></ol><p> 案例：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230713214105605-1691132000293293.png" alt="image-20230713214105605"></p><hr><p>范例练习：</p><p>服务器端改写版</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230714082640269-1691132000294294.png" alt="image-20230714082640269"></p><p>客户端改写版</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230714082713372-1691132000294295.png" alt="image-20230714082713372"></p><hr><p>集合IO流写入文本文件  接收端改进</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230714083534991-1691132000294296.png" alt="image-20230714083534991"></p><hr><p>在读取文件写入文件  服务器反馈练习中</p><p>出现一个问题，服务器端一直等待接收数据</p><p>原因：读数据的方法是堵塞式的</p><p>解决方法：自定义结束标记；使用shutdownOutput( )<strong>推荐</strong></p><hr><p>多线程改进问题中  需要不同的文件名</p><p>解决办法：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230714110905283-1691132000294298.png" alt="image-20230714110905283"></p><hr><p>实现Runnable接口 重写run方法  来开启线程 </p><hr><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>函数式编程思想概述</p><p>λ  这是lambda符号</p><p>在数学中函数就是有输入量、输出量的一套计算方案，也就是  “拿数据做操作”</p><p>面向对象思想强调  “必须通过对象的形式来做事情”</p><p>函数式思想则尽量忽略面向对象的复杂语法：  “强调做什么，而不是以什么形式去做”</p><p>我们要学的Lambda表达式就是函数式思想的体现</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230714114345033-1691132000294297.png" alt="image-20230714114345033"></p><hr><h3 id="Lambda的标准格式"><a href="#Lambda的标准格式" class="headerlink" title="Lambda的标准格式"></a>Lambda的标准格式</h3><p>组成Lambda表达式的三要素：<strong>形式参数，箭头，代码块</strong></p><p>区别：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230714115324843-1691132000294299.png" alt="image-20230714115324843"></p><p><strong>格式：</strong></p><ul><li>格式：**(形式参数)  -&gt;  {代码块}**</li><li>形式参数：如果有多个参数，参数之间用逗号隔开；如果没有参数，留空即可</li><li>-&gt; ：由英文中画线和大于符号组成，固定写法。代表指向动作</li><li>代码块：是我们具体要做的事情，也就是以前我们写的方法体内容</li></ul><hr><h3 id="Lambda表达式的练习"><a href="#Lambda表达式的练习" class="headerlink" title="Lambda表达式的练习"></a>Lambda表达式的练习</h3><p>Lambda表达式的使用前提</p><ul><li>有一个接口</li><li>有且仅有一个抽象方法</li></ul><p>练习123</p><hr><h3 id="Lambda表达式的省略模式"><a href="#Lambda表达式的省略模式" class="headerlink" title="Lambda表达式的省略模式"></a>Lambda表达式的省略模式</h3><p>省略规则：</p><ul><li><strong>参数类型可以省略。但是多个参数的情况下，不能只省略一个</strong></li><li><strong>如果参数有且仅有一个，那么小括号可以省略</strong></li><li><strong>如果代码块的语句只有一条，可以省略大括号和分号，甚至是return</strong></li></ul><hr><h3 id="Lambda表达式的注意事项"><a href="#Lambda表达式的注意事项" class="headerlink" title="Lambda表达式的注意事项"></a>Lambda表达式的注意事项</h3><p>注意事项：</p><ul><li><p>使用Lambda必须要有接口，并且要求接口中有且仅有一个抽象方法</p></li><li><p>必须有上下文环境，才能推导出Lambda对应的接口</p><p>​根据<strong>局部变量的赋值</strong>得知Lambda对应的接口：Runnable  r = ()  -&gt;  System.out.println(“Lambda表达式”);</p><p>​根据<strong>调用方法的参数</strong>得知Lambda对应的接口：new Thread( ()  -&gt;  System.out.println(“Lambda表达式”)).start()；</p></li></ul><hr><h3 id="Lambda表达式和匿名内部类的区别"><a href="#Lambda表达式和匿名内部类的区别" class="headerlink" title="Lambda表达式和匿名内部类的区别"></a>Lambda表达式和匿名内部类的区别</h3><p>所需类型不同</p><ul><li>匿名内部类：可以是接口，也可以是抽象类，还可以是具体类</li><li>Lambda表达式：只能是接口</li></ul><p>使用限制不同</p><ul><li>如果接口中有且仅有一个抽象方法，可以使用Lambda表达式，也可以使用匿名内部类</li><li>如果接口中多于一个抽象方法，只能使用匿名内部类，而不能使用Lambda表达式</li></ul><p>实现原理不同</p><ul><li>匿名内部类：编译之后，产生一个单独的.class字节码文件</li><li>Lambda表达式：编译之后，没有一个单独的.class字节码文件。对应的字节码文件会在运行的时候动态生成</li></ul><hr><h2 id="接口组成更新"><a href="#接口组成更新" class="headerlink" title="接口组成更新"></a>接口组成更新</h2><p>接口组成更新概述</p><p>接口的组成</p><ul><li><p>常量</p><p>pubic static final</p></li><li><p>抽象方法</p><p>public abstract</p></li><li><p>默认方法（Java 8）</p></li><li><p>静态方法（Java 8）</p></li><li><p>私有方法（Java 9）</p></li></ul><hr><h3 id="接口中的默认方法"><a href="#接口中的默认方法" class="headerlink" title="接口中的默认方法"></a>接口中的默认方法</h3><p>接口中默认方法的定义格式：</p><ul><li>格式：public <strong>default</strong> 返回值类型  方法名(参数列表)  {  }</li><li>范例：public <strong>default</strong> void show3( )  {  }</li></ul><p>接口中默认方法的<em><strong>注意事项</strong></em>：</p><ul><li>默认方法不是抽象方法，所以不强制重写。但是可以被重写，重写的时候去掉default关键字</li><li>public可以省略，default不能省略</li></ul><hr><h3 id="接口中的静态方法"><a href="#接口中的静态方法" class="headerlink" title="接口中的静态方法"></a>接口中的静态方法</h3><p>接口中静态方法的定义格式：</p><ul><li>格式：public <strong>static</strong> 返回值类型 方法名(参数列表) {  }</li><li>范例：public <strong>static</strong> void show( )  {   }</li></ul><p>接口中静态方法的在<em><strong>注意事项</strong></em>：</p><ul><li>静态方法只能通过接口名调用，不能通过实现类名或者对象名调用</li><li>public可以省略，static不能省略</li></ul><hr><h3 id="接口中私有方法"><a href="#接口中私有方法" class="headerlink" title="接口中私有方法"></a>接口中私有方法</h3><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230714172415270-1691132000294301.png" alt="image-20230714172415270"></p><p>接口中私有方法的定义格式：</p><ul><li><p>格式1：private 返回值类型  方法名(参数列表) {  }</p></li><li><p>范例1：private void show()  {  }</p></li><li><p>格式2：private static 返回值类型  方法名(参数列表)  {  }</p></li><li><p>范例2：private static void method()  {  }</p><p>接口中私有方法的<strong>注意事项</strong>:</p></li><li><p>默认方法可以调用私有的静态方法和非静态方法</p></li><li><p>静态方法只能调用私有的静态方法</p></li></ul><hr><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230714190228547-1691132000294300.png" alt="image-20230714190228547"></p><hr><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230714192019791-1691132000294302.png" alt="image-20230714192019791"></p><hr><h3 id="方法引用符"><a href="#方法引用符" class="headerlink" title="方法引用符"></a>方法引用符</h3><p>方法引用符</p><ul><li><strong>::</strong>  该符号为引用运算符，而它所在的表达式被称为方法引用</li></ul><p>回顾一下体验方法中的代码</p><ul><li><p>Lambda 表达式 :    usePrintable(s -&gt; System.out.println(s));</p><p>分析：拿到参数s之后通过Lambda表达式。传递给System.out.println方法去处理</p></li><li><p>方法引用：usePrintable(System.out <strong>::</strong> println);</p><p>分析：直接使用System.out中的println方法来取代lambda，代码更加简介</p></li></ul><p>推导与省略</p><ul><li>如果使用Lambda，那么根据 “可推导就是可省略” 的原则，无需指定参数类型，也无需指定的重载形式，它们都将被自动推导</li><li>如果使用方法引用，也是同样可以根据上下文进行推导</li><li>方法引用是Lambda的孪生兄弟</li></ul><hr><h3 id="Lambda表达式支持的方法引用"><a href="#Lambda表达式支持的方法引用" class="headerlink" title="Lambda表达式支持的方法引用"></a>Lambda表达式支持的方法引用</h3><p>常见的引用方式：</p><ul><li>引用类方法</li><li>引用对象的实例方法</li><li>引用类的实例方法</li><li>引用构造器</li></ul><h4 id="引用类方法"><a href="#引用类方法" class="headerlink" title="引用类方法"></a>引用类方法</h4><p>引用类方法，其实就是引用类的静态方法</p><ul><li><p>格式：<strong>类名 :: 静态方法</strong></p></li><li><p>范例：Integer::parselnt</p><p>Integer类的方法：public  static int parseInt（String s）将此String转换为int类型数据</p></li></ul><p>示例：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230715081515185-1691132000294303.png" alt="image-20230715081515185"></p><hr><h4 id="引用对象的实例方法"><a href="#引用对象的实例方法" class="headerlink" title="引用对象的实例方法"></a>引用对象的实例方法</h4><p>引用对象的实例方法，其实就引用类中的成员方法</p><ul><li>格式：<strong>对象::成员方法</strong></li><li>范例：”HelloWorld”::toUpperCase</li></ul><p>示例：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230715083040573-1691132000294305.png" alt="image-20230715083040573"></p><hr><h4 id="引用类的实例方法"><a href="#引用类的实例方法" class="headerlink" title="引用类的实例方法"></a>引用类的实例方法</h4><p>引用类的实例方法，其实就是引用类中的成员方法</p><ul><li><p>格式：<strong>类名::成员方法</strong></p></li><li><p>范例：String::substring</p><p>String类中的方法：public String substring（int beginIndex，int endIndex）</p><p>从beginIndex开始到endIndex结束，截取字符串。返回一个子串，子串的长度为endIndex-beginIndex</p></li></ul><p>示例：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230715085038064-1691132000294306.png" alt="image-20230715085038064"></p><hr><h4 id="引用构造器"><a href="#引用构造器" class="headerlink" title="引用构造器"></a>引用构造器</h4><p>引用构造器，其实就是引用构造方法</p><ul><li>格式：<strong>类名::new</strong></li><li>范例：Student::new</li></ul><p>示例：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230715091300592-1691132000294304.png" alt="image-20230715091300592"></p><hr><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p><strong>函数式接口：有且仅有一个抽象方法的接口</strong></p><p>Java中的函数式编程体现就是Lambda表达式，所以函数式接口就是可以适用于Lambda使用的接口</p><p>只有确保接口中有且仅有一个抽象方法，Java中的Lambda才能顺利的进行推导</p><p>如何检测一个接口是不是函数式接口呢？</p><ul><li><strong>@FunctionalInterface</strong></li><li>放在接口定义的上方：如果接口是函数式接口，编译通过；如果不是，编译失败</li></ul><p><strong>注意</strong></p><ul><li>我们自己定义函数式接口的时候，@FunctionalInterface是可选的，就算我不写这个注解，只要保证满足函数式接口定义的条件，也照样是函数式接口，但是，<strong>建议加上</strong>该注解</li></ul><hr><h3 id="函数式接口作为方法的参数"><a href="#函数式接口作为方法的参数" class="headerlink" title="函数式接口作为方法的参数"></a>函数式接口作为方法的参数</h3><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230715093516928-1691132000294307.png" alt="image-20230715093516928"></p><hr><h3 id="函数式接口作为方法的返回值"><a href="#函数式接口作为方法的返回值" class="headerlink" title="函数式接口作为方法的返回值"></a>函数式接口作为方法的返回值</h3><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230715101454604-1691132000294308.png" alt="image-20230715101454604"></p><p>示例：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230715101433241-1691132000294311.png" alt="image-20230715101433241"></p><hr><h2 id="常用的函数式接口"><a href="#常用的函数式接口" class="headerlink" title="常用的函数式接口"></a>常用的函数式接口</h2><p>Java 8在Java.util.function包下预定义了大量的函数式接口供我们使用</p><p>重点学习下面4个接口</p><ul><li>Supplier接口</li><li>Consumer接口</li><li>Predicate接口</li><li>Function接口</li></ul><h3 id="Supplier接口"><a href="#Supplier接口" class="headerlink" title="Supplier接口"></a>Supplier接口</h3><p>Supplier&lt;T&gt;：包含一个无参的方法</p><ul><li>T get()：获得结果</li><li>该方法不需要参数，它会按照某种实现逻辑(由Lambda表达式实现)返回一个数据</li><li>Supplier&lt;T&gt; 接口也被称为生产型接口，如果我们指定了接口的泛型是什么类型，那么接口中的get方法就会生产什么类型的数据供我们使用</li></ul><p>使用示例：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230715103200034-1691132000294310.png" alt="image-20230715103200034"></p><hr><p>示例2：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230715104448697-1691132000294309.png" alt="image-20230715104448697"></p><hr><h3 id="Consumer接口"><a href="#Consumer接口" class="headerlink" title="Consumer接口"></a>Consumer接口</h3><p>COnsumer&lt;T&gt;：包含两个方法</p><ul><li>void accept(T t)：对给定的参数执行此操作</li><li>default Consumer &lt;T&gt; andThen (Consumer after)：返回一个组合的Consumer，一次执行此操作，然后执行after操作</li><li>Consumer &lt;T&gt; 接口也被称为消费型接口，它消费的数据的数据类型由泛型指定</li></ul><p>使用示例：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230715110155878-1691132000294312.png" alt="image-20230715110155878"></p><hr><p>打印示例:</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230715113033658-1691132000294314.png" alt="image-20230715113033658"></p><hr><h3 id="Predicate接口"><a href="#Predicate接口" class="headerlink" title="Predicate接口"></a>Predicate接口</h3><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230715115250551-1691132000294313.png" alt="image-20230715115250551"></p><p>使用示例：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230715120310689-1691132000294316.png" alt="image-20230715120310689"></p><p>and   or 的使用</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230715134839436-1691132000294315.png" alt="image-20230715134839436"></p><p>筛选满足条件的集合</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230715140034478-1691132000294317.png" alt="image-20230715140034478"></p><hr><h3 id="Function接口"><a href="#Function接口" class="headerlink" title="Function接口"></a>Function接口</h3><p>Function&lt;T,R&gt;：常用的两个方法</p><ul><li>R apply(T t)：将此函数应用于给定的参数</li><li>default &lt;V&gt; Function andThen(Function after)：返回一个组合函数，首先将该函数应用于输入，然后after函数应用于结果</li><li>Function&lt;T,R&gt;接口通常用于对参数进行处理，转换(处理逻辑由Lambda表达式实现)，然后返回一个新的值</li></ul><p>示例：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230715142723289-1691132000295319.png" alt="image-20230715142723289"></p><p>示例：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230715144902749-1691132000294318.png" alt="image-20230715144902749"></p><hr><h2 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h2><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230715151528973-1691132000295320.png" alt="image-20230715151528973"></p><hr><h3 id="Stream流的操作"><a href="#Stream流的操作" class="headerlink" title="Stream流的操作"></a>Stream流的操作</h3><p>Stream流的使用</p><ul><li><p>生成流</p><p>通过数据源(集合，数组等)生成流</p><p>list.stream()</p></li><li><p>中间操作</p><p>一个流后面可以跟随零个或多个中间操作，其目的主要是打开流，做出某种程度的数据过滤/映射，然后返回一个新的流，交给下一个操作使用</p><p>filter( )</p></li><li><p>终结操作</p><p>一个流只能有一个终结操作，当这个操作执行后，流就被使用”光”了，无法再被操作。所以这必定是流的最后一个操作</p><p>forEach( )</p></li></ul><hr><h3 id="Stream流的常见生成方式"><a href="#Stream流的常见生成方式" class="headerlink" title="Stream流的常见生成方式"></a>Stream流的常见生成方式</h3><ul><li><p><strong>Collection</strong>体系的集合可以使用默认方法<strong>stream()</strong> 生成流</p><p>default Stream &lt;E&gt; stream()</p></li><li><p><strong>Map</strong>体系的集合间接的生成流</p></li><li><p>数组可以通过Stream接口的静态方法**of(T…values)**生成流</p></li></ul><p>三种生成方式示例：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230715153645316-1691132000295321.png" alt="image-20230715153645316"></p><hr><h3 id="Stream流的常见中间操作方法"><a href="#Stream流的常见中间操作方法" class="headerlink" title="Stream流的常见中间操作方法"></a>Stream流的常见中间操作方法</h3><ul><li><p>Stream&lt;T&gt; <strong>filter</strong>(Predicate predicate)：用于对流中的数据进行过滤</p><p>Predicate接口中的方法</p><p>boolean test(T t)：对给定的参数进行判断，返回一个布尔值</p></li></ul><p>filter使用示例：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230715154654801-1691132000295322.png" alt="image-20230715154654801"></p><hr><ul><li>Stream&lt;T&gt; <strong>limit</strong>(long maxSize)：返回此流中的元素组成的流，截取前指定参数个数的数据</li><li>Stream&lt;T&gt; <strong>skip</strong>(long n)：跳过指定参数个数的数据，返回由该流的剩余元素组成的流</li></ul><p>limit和skip的使用示例：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230715160339864-1691132000295323.png" alt="image-20230715160339864"></p><hr><ul><li>Static &lt;T&gt; Stream &lt;T&gt; <strong>concat</strong> (Stream a,Stream b)：合并a和b两个流为一个流</li><li>Stream&lt;T&gt; <strong>distinct</strong>()：返回由该流的不同元素（根据Object.equals(Object))组成的流</li></ul><p>concat和distinct的使用示例：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230715161607030-1691132000295325.png" alt="image-20230715161607030"></p><hr><ul><li>Stream &lt;T&gt; <strong>sorted</strong>()：返回由此流的元素组成的流，根据自然顺序排序</li><li>Stream &lt;T&gt; **sorted (Comparator comparator)**：返回由该流的元素组成的流，根据提供的Comparator进行排序</li></ul><p>sort排序示例：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230715165542719-1691132000295324.png" alt="image-20230715165542719"></p><hr><ul><li><p>&lt;R&gt; Stream &lt;R&gt; <strong>map</strong>(Function mapper)：返回由给定函数应用于此流的元素的结果组成的流</p><p>Function接口中的方法R  apply(T t)</p></li><li><p>IntStream <strong>mapToInt</strong>(ToIntFunction mapper)：返回一个IntStream其中包含将给定函数应用于此流的元素的结果</p></li></ul><p>​IntStream：表示原始int流</p><p>​ToIntFunction接口中的方法intapplyAsInt(T value)</p><p>map和mapToInt方法的使用</p><p>示例：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230715172628619-1691132000295326.png" alt="image-20230715172628619"></p><hr><p>mapToInt  返回类型为IntStream  此类中有一个sum方法比较实用</p><p>示例：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230715172733645-1691132000295328.png" alt="image-20230715172733645"></p><hr><h3 id="Stream流的常见终结操作"><a href="#Stream流的常见终结操作" class="headerlink" title="Stream流的常见终结操作"></a>Stream流的常见终结操作</h3><p>常见的：</p><ul><li><p>void <strong>forEach</strong>(Consumber action)：对此流的每个元素执行操作</p><p>​Consumer接口中的方法void accept(T t)：对给定的参数执行此操作</p></li><li><p>long <strong>count</strong>()：返回此流中的元素数</p></li></ul><p>forEach和count方法示例：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230715185906300-1691132000295327.png" alt="image-20230715185906300"></p><hr><hr><h3 id="综合练习"><a href="#综合练习" class="headerlink" title="综合练习"></a>综合练习</h3><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230715192004494-1691132000295330.png" alt="image-20230715192004494"></p><hr><h3 id="Stream流的收集操作"><a href="#Stream流的收集操作" class="headerlink" title="Stream流的收集操作"></a>Stream流的收集操作</h3><p>对数据使用Stream流的方式操作完毕后，我想把流中的数据收集到集合中，该怎么办呢？</p><p>Stream流的收集方法</p><ul><li>R <strong>collect</strong>(Collector collector)</li><li>但是这个收集方法的参数是一个Collector接口</li></ul><p>工具类<strong>Collectors</strong>提供了具体的收集方式</p><ul><li>public static&lt;T&gt; Collector **toList()**：把元素收集到List集合中</li><li>public static&lt;T&gt; Collector **toSet()**：把元素收集到Set集合中</li><li>public static Collector <strong>toMap</strong>(Function keyMapper,Function valueMapper)：把元素收集到Map集合中</li></ul><p>使用范例：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230715202301338-1691132000295329.png" alt="image-20230715202301338"></p><hr><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="类加载流程"><a href="#类加载流程" class="headerlink" title="类加载流程"></a>类加载流程</h3><p>当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过类的加载，类的连接，类的初始化这三个步骤来对类进行初始化。如果不出现意外情况，JVM将会连续完成这三个步骤，所以有时也把这三个步骤统称为类加载或者类初始化</p><p>类的加载：</p><ul><li>就是指将class文件读入内存并为之创建一个java.lang.Class对象</li><li>任何类被使用时，系统都会为之建立一个java.lang.Class对象</li></ul><p>类的连接</p><ul><li>验证阶段：用于检验被加载的类是否有正确的内部结构，并和其他类协调一致</li><li>准备阶段：负责为类的类变量分配内存，并设置默认初始化值</li><li>解析阶段：将类的二进制数据中的符号引用替换为直接引用</li></ul><p>类的初始化</p><ul><li>在该阶段，主要就是对类变量进行初始化</li></ul><p>类的初始化步骤</p><ul><li>假如类还未被加载和连接，则程序先加载并连接该类</li><li>加入该类的直接父类还未被初始化，则先初始化其直接父类</li><li>加入类中有初始化语句，则系统依次执行这些初始化语句</li></ul><p><strong>注意：</strong>在执行第二个步骤的时候，系统对直接父类的初始化步骤也遵循初始化也遵循初始化步骤1-3</p><p>类的初始化时机：</p><ul><li>创建类的实例</li><li>调用类的类方法</li><li>访问类或者接口的类变量，或者为该类变量赋值</li><li>使用反射方式来强制创建某个类或接口对应的java.lang.Class对象</li><li>初始化某个类的子类</li><li>直接使用java.exe命令来运行某个主类</li></ul><hr><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>类加载器的作用</p><ul><li>负责将.class文件加载到内存中，并为之生成对应的java.lang.Class对象</li><li>虽然我们不用过分关心类加载机制，但是了解这个机制我们就能更好的理解程序的运行</li></ul><p>JVM的类加载机制</p><ul><li>全盘负责：就是当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</li><li>父类委托：就是当一个类加载器负责加载Class时，先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</li><li>缓存机制：保证所有加载过的Class都会被缓存，当程序需要使用某个Class对象时，类加载器先从缓存区中搜索该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存储到缓存区</li><li><strong>类加载器的继承关系：System的父加载器为Platform，而Platform的父加载器为Bootstrap</strong></li></ul><p><strong>ClassLoader中的两个方法</strong></p><ul><li>static ClassLoader <strong>getSystemClassLoad</strong>()：返回用于委派的系统类加载器</li><li>ClassLoader <strong>getParent</strong>()：返回父类加载器进行委派</li></ul><hr><h3 id="反射-1"><a href="#反射-1" class="headerlink" title="反射"></a>反射</h3><p>概述：</p><p>Java反射机制：是指在运行时去获取一个类的变量和方法信息。然后通过获取到的信息来创建对象，调用方法的一种机制。由于这种动态性，可以极大的增强程序的灵活性，程序不用再编译期就完成确定，在运行期仍然可以扩展</p><h3 id="获取Class类的对象"><a href="#获取Class类的对象" class="headerlink" title="获取Class类的对象"></a>获取Class类的对象</h3><p>我们要想通过反射区使用一个类，首先我们要获取到该类的字节码文件对象，也就是类型为Class类型的对象</p><p>这里我们提供三种方式获取Class类型的对象</p><ul><li><p>实用类的<strong>Class属性来获取该类对应的Class</strong>对象。举例：Student.Class将会返回Student类对应的Class对象</p></li><li><p>调用对象的<strong>getClass</strong>()方法，返回该对象所属类对应的Class对象</p><p>该方法是Object类中的方法，所有的Java对象都可以调用该方法</p></li><li><p>使用Class类中的静态方法<strong>forName</strong>(String className)，该方法需要传入字符串参数，该字符串参数的值是某个类的全路径，也就是完整包名的路径</p></li></ul><p>三种方法使用示例：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230717071802426-1691132000295331.png" alt="image-20230717071802426"></p><hr><h3 id="反射获取构造方法并使用"><a href="#反射获取构造方法并使用" class="headerlink" title="反射获取构造方法并使用"></a>反射获取构造方法并使用</h3><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230717074116891-1691132000295332.png" alt="image-20230717074116891"></p><p>获取示例：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230717073903136-1691132000295333.png" alt="image-20230717073903136"></p><hr><p>反射获取构造方法使用练习1</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230717080556187-1691132000295335.png" alt="image-20230717080556187"></p><ul><li><strong>基本数据类型也可以通过.class得到对应的Class类型</strong></li></ul><hr><p>反射获取构造方法使用练习2</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230717082518854-1691132000295334.png" alt="image-20230717082518854"></p><ul><li><strong>public void setAccessible(boolean flag)：值为true，取消访问检查</strong></li></ul><p><strong>称为暴力反射</strong></p><p><strong>新建对象的时候无法使用私有的构造方法  而反射可以</strong></p><hr><h3 id="反射获取成员变量并使用"><a href="#反射获取成员变量并使用" class="headerlink" title="反射获取成员变量并使用"></a>反射获取成员变量并使用</h3><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230717085908033-1691132000295336.png" alt="image-20230717085908033"></p><p>示例：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230717085754654-1691132000295337.png" alt="image-20230717085754654"></p><hr><p>反射获取成员变量并使用练习    </p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230717091253406-1691132000295338.png" alt="image-20230717091253406"></p><hr><h3 id="反射获取成员方法"><a href="#反射获取成员方法" class="headerlink" title="反射获取成员方法"></a>反射获取成员方法</h3><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230717095100330-1691132000295341.png" alt="image-20230717095100330"></p><p>示例：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230717094943585-1691132000295339.png" alt="image-20230717094943585"></p><hr><p>使用练习</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230717100624557-1691132000295340.png" alt="image-20230717100624557"></p><hr><h3 id="反射练习之越过泛型检查"><a href="#反射练习之越过泛型检查" class="headerlink" title="反射练习之越过泛型检查"></a>反射练习之越过泛型检查</h3><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230717101513938-1691132000295342.png" alt="image-20230717101513938"></p><hr><h3 id="反射练习之运行配置文件指定内容"><a href="#反射练习之运行配置文件指定内容" class="headerlink" title="反射练习之运行配置文件指定内容"></a>反射练习之运行配置文件指定内容</h3><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230717103549211-1691132000295343.png" alt="image-20230717103549211"></p><hr><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>概述：</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230717103920137-1691132000295344.png" alt="image-20230717103920137"></p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230717104054429-1691132000295345.png" alt="image-20230717104054429"></p><hr><h3 id="模块的基本使用"><a href="#模块的基本使用" class="headerlink" title="模块的基本使用"></a>模块的基本使用</h3><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230717105659953-1691132000295346.png" alt="image-20230717105659953"></p><p>创建module-info.java描述文件  exports 包  导出包    requires 模块   依赖模块</p><hr><h3 id="模块服务的使用"><a href="#模块服务的使用" class="headerlink" title="模块服务的使用"></a>模块服务的使用</h3><p>服务：从Java6开始，Java提供了一种服务机制，允许服务提供者和服务使用者之间完成解耦。简单地说，就是服务使用者只面向接口编程，但不清楚服务提供者的实现类</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230717110817235-1691132000296347.png" alt="image-20230717110817235"></p><p><strong>uese 声明服务接口  provides 为服务接口指定实现类</strong></p><p>模块服务的使用步骤</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230717112242107-1691132000296348.png" alt="image-20230717112242107"></p><p>使用的话还需要 加载服务</p><p><img src="/../images/Java-SE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230717112400590-1691132000296349.png" alt="image-20230717112400590"></p><p>调用load方法 参数为.Class   可以遍历</p><hr><p>🎇🎇🎇</p>]]></content>
      
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/03/23/hello-world/"/>
      <url>/2023/03/23/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
